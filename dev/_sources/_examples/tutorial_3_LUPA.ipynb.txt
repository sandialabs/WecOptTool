{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Tutorial 3 - LUPA\n",
    "\n",
    "The main goal of this tutorial is to demonstrate how to set up a WEC design problem with a more complex and realistic setup.\n",
    "We use the [Lab Upgrade Point Absorber (LUPA)](https://pmec-osu.github.io/LUPA/) device, an open source two-body heaving point absorber under development by Oregon State University.\n",
    "A deep dive video demonstration of the LUPA device and its features can be viewed [here](https://www.youtube.com/watch?v=gCcAu7H9lQI).\n",
    "We will numerically replicate LUPA testing in the Large Wave Flume at the [O.H. Hinsdale Wave Research Laboratory](https://engineering.oregonstate.edu/wave-lab) in order to provide further design optimization for the WEC device concept.\n",
    "This tutorial builds on the previous ones by introducing:\n",
    " \n",
    "* a WEC comprised of multiple bodies\n",
    "* setting up a WEC with multiple degrees of freedom (DOF) using generalized modes\n",
    "* more complex PTO kinematics that depend on more than one WEC DOF \n",
    "* realistic constraints including generator maximum and continuous torque, and maximum rotational speed\n",
    "* irregular waves\n",
    "* mooring system dynamics\n",
    "\n",
    "A secondary goal for this tutorial is to serve as a tool for those who are planning to run experiments with the LUPA device, to inform their experiment design.  \n",
    "\n",
    "As with previous tutorials, this tutorial consists of two parts, with the second section building upon the first.\n",
    "\n",
    "1. [Optimal control of a two-body WEC](#1.-Optimal-control-of-a-two-body-WEC)\n",
    "2. [Control co-design of the PTO sprocket sizing for maximum electrical power](#2.-Control-co-design-of-the-PTO-sprocket-sizing-for-maximum-electrical-power)\n",
    "\n",
    "<p><img src=https://live.staticflickr.com/65535/52793669495_72ba57da99_z.jpg alt=\"Digital rendering of the LUPA\" width=\"307\"> <img src=https://live.staticflickr.com/65535/52792718812_b750791167_k.jpg alt=\"Picture of the LUPA floating in the flume in calm water. Both bodies and mooring are visible.\" width=\"500\"> <img src=https://live.staticflickr.com/65535/52793276446_9b35889ccd_k.jpg alt=\"Picture of the LUPA in the dry flume. Both bodies and mooring are visible. A ladder and person next to it gives context of the scale.\" width=\"500\"></p>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "import gmsh, pygmsh\n",
    "import capytaine as cpy\n",
    "from capytaine.io.meshio import load_from_meshio\n",
    "import autograd.numpy as np\n",
    "import matplotlib.pyplot as plt\n",
    "import xarray as xr\n",
    "from scipy.optimize import brute\n",
    "\n",
    "import wecopttool as wot\n",
    "\n",
    "## set colorblind-friendly colormap for plots\n",
    "plt.style.use('tableau-colorblind10')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 1. Optimal control of a two-body WEC\n",
    "\n",
    "### WEC geometry\n",
    "The creation of the `WEC` object is fundamentally identical to previous tutorials, where we use meshes of the WEC to create Capytaine `FloatingBody` objects, run BEM using Capytaine, and use the `WEC.from_bem()` method to create the `WEC` object.\n",
    "The key here is that the LUPA is a two-body device (consisting of a float and a spar), which move independently in heave but in unison for all other degrees of freedom.\n",
    "To model this in WecOptTool, we can create a `FloatingBody` object for each body separately with a heave DOF, combine them into a single object afterwards, and be sure the combined mass and inertia properties are properly set.\n",
    "\n",
    "We will analyze the device in its four planar degrees of freedom:\n",
    "\n",
    "* Heave of the buoy\n",
    "* Heave of the spar\n",
    "* Combined device surge\n",
    "* Combined device pitch\n",
    "\n",
    "Here we are using the generalized modes approach; an alternative solution would be to include all 3 planar DOF for each body separately and add two constraints for the pitch and surge to be equal for both bodies.\n",
    "\n",
    "#### LUPA properties\n",
    "The mass properties of the LUPA have been provided from measurements of the physical device by Oregon State University, as follows:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# provided by OSU\n",
    "float_mass_properties = {\n",
    "    'mass': 248.721,\n",
    "    'CG': [0.01, 0, 0.06],\n",
    "    'MOI': [66.1686, 65.3344, 17.16],\n",
    "}\n",
    "\n",
    "spar_mass_properties = {\n",
    "    'mass': 175.536,\n",
    "    'CG': [0, 0, -1.3],\n",
    "    'MOI': [253.6344, 250.4558, 12.746],\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Mesh creation of the float\n",
    "\n",
    "Here we create the mesh based on the dimensions provided by Oregon State University using `pygmsh`, available [here](https://pypi.org/project/pygmsh/).\n",
    "This is the same package used by `geom.py` (click [here](https://sandialabs.github.io/WecOptTool/api_docs/wecopttool.geom.html) for API documentation) containing the predefined WaveBot and AquaHarmonics meshes used in the previous tutorials.\n",
    "\n",
    "The float has a hole where the spar passes through it. \n",
    "In previous versions of this tutorial, the hole was larger than the spar and led to a large spike in the BEM results. \n",
    "The spike has been resolved by making the hole smaller so that the float is flush with the spar.\n",
    "Like the other tutorials, a lid is added to remove any irregular frequency spikes. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# mesh\n",
    "mesh_size_factor = 0.3\n",
    "r1 = 1.0/2  # top radius\n",
    "r2 = 0.4/2  # bottom radius\n",
    "h1 = 0.5  \n",
    "h2 = 0.21\n",
    "freeboard = 0.3\n",
    "r3 = 0.05  # hole radius\n",
    "with pygmsh.occ.Geometry() as geom:\n",
    "    gmsh.option.setNumber('Mesh.MeshSizeFactor', mesh_size_factor)\n",
    "    cyl = geom.add_cylinder([0, 0, 0], [0, 0, -h1], r1)\n",
    "    cone = geom.add_cone([0, 0, -h1], [0, 0, -h2], r1, r2)\n",
    "    geom.translate(cyl, [0, 0, freeboard])\n",
    "    geom.translate(cone, [0, 0, freeboard]) \n",
    "    tmp = geom.boolean_union([cyl, cone])\n",
    "    bar = geom.add_cylinder([0, 0, 10], [0,0,-20], r3)\n",
    "    geom.boolean_difference(tmp, bar)\n",
    "    mesh_float = geom.generate_mesh()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Again, we will only add the heave DOF for now.\n",
    "The surge and pitch will be added after we combine the two `FloatingBody` objects."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# lid\n",
    "mesh_obj = load_from_meshio(mesh_float, 'float')\n",
    "lid_mesh = mesh_obj.generate_lid(z=-1e-2)\n",
    "\n",
    "# floating body\n",
    "float_fb = cpy.FloatingBody(mesh=mesh_obj, lid_mesh=lid_mesh, name=\"float\")\n",
    "float_fb.add_translation_dof(name='Heave')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now visualize the mesh:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# show\n",
    "float_fb.show_matplotlib()\n",
    "\n",
    "# interactive, close pop-up image before being able to continue running the notebook\n",
    "# float_fb.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Mesh creation of the spar\n",
    "\n",
    "We now create the spar mesh in the same way as for the float, with the dimensions given by Oregon State University.\n",
    "\n",
    "<p><img src=https://live.staticflickr.com/65535/52793722023_cd0b2e5d4f_k.jpg alt=\"spar dimensions schematic from OSU\" width=700></p>"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# mesh\n",
    "mesh_size_factor = 0.1\n",
    "r1 = 0.45/2  # body\n",
    "r2 = 0.45  # plate\n",
    "r3 = 0.10/2  # bar\n",
    "h1 = 1.20  \n",
    "h2 = 0.01\n",
    "h3a = 3.684 - 2.05\n",
    "submergence = 2.05 - h1 - h2\n",
    "\n",
    "with pygmsh.occ.Geometry() as geom:\n",
    "    gmsh.option.setNumber('Mesh.MeshSizeFactor', mesh_size_factor)\n",
    "    body = geom.add_cylinder([0, 0, 0], [0, 0, -h1], r1)\n",
    "    geom.translate(body, [0, 0, -submergence])\n",
    "    plate = geom.add_cylinder([0, 0, 0], [0, 0, -h2], r2)\n",
    "    geom.translate(plate, [0, 0, -(submergence+h1)])\n",
    "    bar = geom.add_cylinder([0, 0, h3a], [0, 0, -(h3a+submergence)], r3)\n",
    "    geom.boolean_union([bar, body, plate])\n",
    "    mesh_spar = geom.generate_mesh()"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# lid\n",
    "mesh_obj = load_from_meshio(mesh_spar, 'float')\n",
    "lid_mesh = mesh_obj.generate_lid(z=-1e-2)\n",
    "\n",
    "# floating body\n",
    "spar_fb = cpy.FloatingBody(mesh=mesh_obj, lid_mesh=lid_mesh, name=\"spar\")\n",
    "spar_fb.add_translation_dof(name='Heave')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# show\n",
    "fig = plt.figure()\n",
    "xmin, xmax, ymin, ymax, zmin, zmax = spar_fb.mesh.axis_aligned_bbox\n",
    "scalez = (zmax-zmin) / (xmax-xmin)\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "ax.set_box_aspect(aspect=(1,1,scalez))\n",
    "spar_fb.show_matplotlib(ax=ax)\n",
    "ax.set_xlim(xmin, xmax)\n",
    "ax.set_ylim(ymin, ymax)\n",
    "\n",
    "# interactive, close pop-up image before being able to continue running the notebook\n",
    "# spar_fb.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Combined `FloatingBody`\n",
    "\n",
    "With both WEC bodies defined separately, we can now define the respective centers of mass and rotation centers of the bodies.\n",
    "We will then create a union of the bodies and define the properties for the overall LUPA device.\n",
    "At the equilibrium position the float is neutrally buoyant while the spar is positively buoyant and requires mooring pre-tension.\n",
    "The combined center of mass and moment of inertia can be found by using the given values weighted by the mass (via the parallel axis theorem for the moment of inertia).\n",
    "This is also when we can specify the surge and pitch degrees of freedom.\n",
    "\n",
    "We are using the density of *fresh* water, $\\rho = 1000 kg/m^3$, since we are modeling LUPA in a wave flume."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# density of fresh water\n",
    "rho = 1000\n",
    "\n",
    "# mass properties float\n",
    "mass_float = float_mass_properties['mass']\n",
    "cm_float = np.array(float_mass_properties['CG'])\n",
    "pitch_inertia_float = float_mass_properties['MOI'][1]\n",
    "float_fb.center_of_mass = cm_float\n",
    "float_fb.rotation_center = float_fb.center_of_mass\n",
    "\n",
    "# mass properties spar\n",
    "mass_spar = spar_mass_properties['mass']\n",
    "cm_spar = np.array(spar_mass_properties['CG'])\n",
    "pitch_inertia_spar = spar_mass_properties['MOI'][1]\n",
    "spar_fb.center_of_mass = cm_spar\n",
    "spar_fb.rotation_center = spar_fb.center_of_mass\n",
    "\n",
    "# floating body\n",
    "lupa_fb = float_fb + spar_fb\n",
    "lupa_fb.name = 'LUPA'\n",
    "\n",
    " # mass properties LUPA\n",
    "lupa_fb.center_of_mass = ((mass_float*cm_float + mass_spar*cm_spar)\n",
    "                        / (mass_float + mass_spar))\n",
    "lupa_fb.rotation_center = lupa_fb.center_of_mass\n",
    "\n",
    "# pitch moment of inertia of LUPA using the parallel axis theorem \n",
    "d_float = cm_float[2] - lupa_fb.center_of_mass[2]\n",
    "d_spar = cm_spar[2] - lupa_fb.center_of_mass[2]\n",
    "pitch_inertia = (\n",
    "    pitch_inertia_float + mass_float*d_float**2 + \n",
    "    pitch_inertia_spar + mass_spar*d_spar**2\n",
    ")\n",
    "inertia = np.diag([mass_float, mass_spar, lupa_fb.disp_mass(), pitch_inertia])\n",
    "\n",
    "# additional DOFs\n",
    "lupa_fb.add_translation_dof(name='Surge')\n",
    "lupa_fb.add_rotation_dof(name='Pitch')"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Define Hydrostatics Manually\n",
    "We need to be carefully set up the hydrostatic correctly when combining multiple bodies.\n",
    "The bodies move separately in heave but move together in surge and pitch.\n",
    "Therefore, we should define the individual heave inertia values _for each body_, but define the _total_ surge and pitch inertia values.\n",
    "The inertia then needs to be reformatted as an `xarray.DataArray` to work with Capytaine.\n",
    "The hydrostatic stiffness can be calculated for the total immersed body."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# reorganize inertia values into DataArray for Capytaine\n",
    "rigid_inertia_matrix_xr = xr.DataArray(data=np.asarray((inertia)),\n",
    "                            dims=['influenced_dof', 'radiating_dof'],\n",
    "                            coords={'influenced_dof': list(lupa_fb.dofs),\n",
    "                                    'radiating_dof': list(lupa_fb.dofs)},\n",
    "                            name=\"inertia_matrix\")\n",
    "\n",
    "# Set FloatingBody inertia matrix\n",
    "lupa_fb.inertia_matrix = rigid_inertia_matrix_xr\n",
    "\n",
    "# Calculate hydrostatic stiffness after keeping immersed value\n",
    "lupa_fb = lupa_fb.keep_immersed_part()\n",
    "lupa_fb.hydrostatic_stiffness = lupa_fb.compute_hydrostatic_stiffness(rho=rho)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can now visualize the combined mesh."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# show\n",
    "fig = plt.figure()\n",
    "xmin, xmax, ymin, ymax, zmin, zmax = lupa_fb.mesh.axis_aligned_bbox\n",
    "scalez = (zmax-zmin) / (xmax-xmin)\n",
    "ax = fig.add_subplot(111, projection='3d')\n",
    "ax.set_box_aspect(aspect=(1,1,scalez))\n",
    "lupa_fb.show_matplotlib(ax=ax)\n",
    "ax.set_xlim(xmin, xmax)\n",
    "ax.set_ylim(ymin, ymax)\n",
    "\n",
    "# lupa_fb.show()"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Waves\n",
    "Oregon State University has defined two sets of wave testing conditions for the LUPA: one corresponding to the PacWave South site and a scaling factor of 25, and one for the PacWave North site and a scaling factor of 20. \n",
    "For each site/scale they provide four wave conditions to test at the Oregon State Large Wave Flume (LWF): the maximum 90<sup>th</sup> percentile, maximum percent annual energy, maximum occurrence, and minimum 10<sup>th</sup> percentile. \n",
    "\n",
    "In this tutorial we will use the PacWave South conditions scaled to the LWF and will design for the maximum occurrence wave. \n",
    "The wave conditions are specified in terms of significant wave height and peak period. Waves are mostly fully developed at the PacWave site, so we will use a Pierson-Moskowitz wave spectrum. \n",
    "\n",
    "The irregular wave is created with multiple phase realizations.\n",
    "The solver will be run once for each wave phase realization.\n",
    "Each of these phase realizations leads to a slightly different result for optimal average power.\n",
    "Thus, for irregular wave conditions, it is recommended to include multiple phase realizations.\n",
    "The number of phase realizations required is dependent on the desired accuracy of the result, but it is generally recommended to include enough realizations for the total simulation time to equal 20 minutes.\n",
    "For this tutorial, the number of realizations has been set to 2 to reduce the total runtime. \n",
    "\n",
    "$$ t_{total} = \\frac{n_{realizations}}{f_1} $$\n",
    "\n",
    "Because we are now using irregular waves, we need significantly more frequencies to capture the entire wave spectrum and WEC response. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "waves = {}\n",
    "\n",
    "f1 = 0.02\n",
    "nfreq = 50\n",
    "freq = wot.frequency(f1, nfreq, False)\n",
    "\n",
    "# regular (for testing/setup)\n",
    "amplitude = 0.1\n",
    "wavefreq = 0.4\n",
    "phase = 0\n",
    "wavedir = 0\n",
    "waves['regular'] = wot.waves.regular_wave(f1, nfreq, wavefreq, amplitude, phase, wavedir)\n",
    "\n",
    "nrealizations = 2\n",
    "\n",
    "# irregular wave cases from OSU\n",
    "wave_cases = {\n",
    "    'south_max_90': {'Hs': 0.21, 'Tp': 3.09}, \n",
    "    'south_max_annual': {'Hs': 0.13, 'Tp': 2.35},\n",
    "    'south_max_occurrence': {'Hs': 0.07, 'Tp': 1.90},\n",
    "    'south_min_10': {'Hs': 0.04, 'Tp': 1.48},  \n",
    "    'north_max_90': {'Hs': 0.25, 'Tp': 3.46}, \n",
    "    'north_max_annual': {'Hs': 0.16, 'Tp': 2.63},\n",
    "    'north_max_occurrence': {'Hs': 0.09, 'Tp': 2.13},\n",
    "    'north_min_10': {'Hs': 0.05, 'Tp': 1.68}, \n",
    "}\n",
    "\n",
    "def irregular_wave(hs, tp):\n",
    "    fp = 1/tp\n",
    "    spectrum = lambda f: wot.waves.pierson_moskowitz_spectrum(f, fp, hs)\n",
    "    efth = wot.waves.omnidirectional_spectrum(f1, nfreq, spectrum, \"Pierson-Moskowitz\")\n",
    "    return wot.waves.long_crested_wave(efth,nrealizations=nrealizations)\n",
    "\n",
    "for case, data in wave_cases.items():\n",
    "    waves[case] = irregular_wave(data['Hs'], data['Tp'])"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### BEM\n",
    "With the LUPA geometry and physical properties fully defined, we can now run Capytaine to calculate the hydrodynamic coefficients of the device, as done in previous tutorials.\n",
    "Capytaine can handle generalized modes and will calculate the coefficients for our 4 degrees of freedom.\n",
    "The BEM coefficients have been pre-calculated and are saved in a file.\n",
    "To re-run the BEM, which takes about 1 hour, simply move or delete the existing `data/bem.nc` file."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# read BEM data file if it exists\n",
    "filename = 'data/bem.nc'\n",
    "try:\n",
    "    bem_data = wot.read_netcdf(filename)\n",
    "except:\n",
    "    bem_data = wot.run_bem(lupa_fb, freq, rho=rho)\n",
    "    wot.write_netcdf(filename, bem_data)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We now visualize the BEM results.\n",
    "An irregular frequency at about 5.25 rad/s is visible in many of the plots, but this should not substantially impact our model as the wave energy at this frequency is fairly low. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "wot.utilities.plot_hydrodynamic_coefficients(bem_data)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### PTO system\n",
    "\n",
    "The PTO model is similar to the one developed in Tutorial 2 but using the values corresponding to the LUPA PTO. \n",
    "The main difference is that in the LUPA the gear ratio can be modified by changing the interchangeable sprocket for one with a different radius. \n",
    "The motivation here is that operation in different wave conditions or different control schemes might have different torque and speed requirements. \n",
    "Oregon State University has three sprockets of diameters 81.5mm (8MX-32S-36), 127.3mm (8MX-50S-36), 203.7mm (8MX-80S-36), but the manufacturer provides a larger selection of radius size in this range. \n",
    "\n",
    "The PTO system consists of a [generator](https://akribis-systems.s3-us-west-2.amazonaws.com/pdfs/catalogs/adr-b.pdf), the [interchangeable sprocket](https://assets.gates.com/content/dam/gates/home/knowledge-center/resource-library/catalogs/old-pc_carbon_manual17595_2011.pdf), and two [idler pulleys](https://dpk3n3gg92jwt.cloudfront.net/domains/gates.pt/pdf/77234200.pdf) driven by a belt.\n",
    "\n",
    "<p><img src=https://live.staticflickr.com/65535/52793276361_ff6a78ce4f_k.jpg alt=\"Schematic of the PTO system showing dimensions and parts.\" width=740> <img src=https://live.staticflickr.com/65535/52793518059_5f4b559d2a_h.jpg alt=\"Digital rendering of the LUPA with PTO mechanism visible.\" width=458></p>\n",
    "\n",
    "We start by defining all the manufacturer-specified components:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "conv_d = 0.0254  # in -> m\n",
    "conv_m = 0.453592  # lb -> kg\n",
    "conv_moi = 0.453592 * 0.3048**2  # lb*ft^2 -> kg*m^2\n",
    "conv_s = 2*np.pi / 60  # rpm -> rad/s\n",
    "\n",
    "# sprocket\n",
    "sprockets = {\n",
    "    '8MX-32S-36': {\n",
    "        'diameter': 3.208 * conv_d,\n",
    "        'mass': 1.7 * conv_m,\n",
    "        'MOI': 0.02 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-33S-36': {\n",
    "        'diameter': 3.308 * conv_d,\n",
    "        'mass':  3.31* conv_m,\n",
    "        'MOI': 0.022 * conv_moi,\n",
    "        'design': 'AF',\n",
    "    },\n",
    "    '8MX-34S-36': {\n",
    "        'diameter': 3.409 * conv_d,\n",
    "        'mass': 1.8 * conv_m,\n",
    "        'MOI': 0.026 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-35S-36': {\n",
    "        'diameter': 3.509 * conv_d,\n",
    "        'mass': 3.51 * conv_m,\n",
    "        'MOI': 0.029 * conv_moi,\n",
    "        'design': 'AF',\n",
    "    },\n",
    "    '8MX-36S-36': {\n",
    "        'diameter': 3.609 * conv_d,\n",
    "        'mass': 2.1 * conv_m,\n",
    "        'MOI': 0.032 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-37S-36': {\n",
    "        'diameter': 3.709 * conv_d,\n",
    "        'mass': 3.78 * conv_m,\n",
    "        'MOI': 0.039 * conv_moi,\n",
    "        'design': 'AF',\n",
    "    },\n",
    "    '8MX-38S-36': {\n",
    "        'diameter': 3.810 * conv_d,\n",
    "        'mass': 2.4 * conv_m,\n",
    "        'MOI': 0.04 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-39S-36': {\n",
    "        'diameter': 3.910 * conv_d,\n",
    "        'mass': 3.91 * conv_m,\n",
    "        'MOI': 0.048 * conv_moi,\n",
    "        'design': 'AF',\n",
    "    },\n",
    "    '8MX-40S-36': {\n",
    "        'diameter': 4.010 * conv_d,\n",
    "        'mass': 2.5 * conv_m,\n",
    "        'MOI': 0.049 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-41S-36': {\n",
    "        'diameter': 4.110 * conv_d,\n",
    "        'mass': 4.11 * conv_m,\n",
    "        'MOI': 0.057 * conv_moi,\n",
    "        'design': 'AF',\n",
    "    },\n",
    "    '8MX-42S-36': {\n",
    "        'diameter': 4.211 * conv_d,\n",
    "        'mass': 2.8 * conv_m,\n",
    "        'MOI': 0.061 * conv_moi,\n",
    "        'design': 'AF-1',  \n",
    "    },\n",
    "    '8MX-45S-36': {\n",
    "        'diameter': 4.511 * conv_d,\n",
    "        'mass': 3.8 * conv_m,\n",
    "        'MOI': 0.09 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-48S-36': {\n",
    "        'diameter': 4.812 * conv_d,\n",
    "        'mass': 4.3 * conv_m,\n",
    "        'MOI': 0.114 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-50S-36': {\n",
    "        'diameter': 5.013 * conv_d,\n",
    "        'mass': 5.1 * conv_m,\n",
    "        'MOI': 0.143 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-53S-36': {\n",
    "        'diameter': 5.314 * conv_d,\n",
    "        'mass': 5.5 * conv_m,\n",
    "        'MOI': 0.169 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-56S-36': {\n",
    "        'diameter': 5.614 * conv_d,\n",
    "        'mass': 6.5 * conv_m,\n",
    "        'MOI': 0.221 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-60S-36': {\n",
    "        'diameter': 6.015 * conv_d,\n",
    "        'mass': 8.9 * conv_m,\n",
    "        'MOI': 0.352 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-63S-36': {\n",
    "        'diameter': 6.316 * conv_d,\n",
    "        'mass': 10.4 * conv_m,\n",
    "        'MOI': 0.556 * conv_moi,\n",
    "        'design': 'AF-1',\n",
    "    },\n",
    "    '8MX-67S-36': {\n",
    "        'diameter': 6.717 * conv_d,\n",
    "        'mass': 6.5 * conv_m,\n",
    "        'MOI': 0.307 * conv_moi,\n",
    "        'design': 'DF-1',\n",
    "    },\n",
    "    '8MX-71S-36': {\n",
    "        'diameter': 7.118 * conv_d,\n",
    "        'mass': 7.0 * conv_m,\n",
    "        'MOI': 0.365 * conv_moi,\n",
    "        'design': 'DF-1',\n",
    "    },\n",
    "    '8MX-75S-36': {\n",
    "        'diameter': 7.519 * conv_d,\n",
    "        'mass': 7.3 * conv_m,\n",
    "        'MOI': 0.423 * conv_moi, \n",
    "        'design': 'DF-1',\n",
    "    },\n",
    "    '8MX-80S-36': {\n",
    "        'diameter': 8.020 * conv_d,\n",
    "        'mass': 17.9 * conv_m,\n",
    "        'MOI': 1.202 * conv_moi,  \n",
    "        'design': 'BF-1',\n",
    "    },\n",
    "}\n",
    "\n",
    "# idler pulleys\n",
    "idler_pulley = {\n",
    "    'model': 'Gates 4.25X2.00-IDL-FLAT',\n",
    "    'diameter': 4.25 * conv_d, \n",
    "    'face_width': 2.00 * conv_d,\n",
    "    'mass': 7.6 * conv_m,\n",
    "    'max_rpm': 5840,\n",
    "    'MOI': None,  # Not specified\n",
    "}\n",
    "\n",
    "# generator\n",
    "# Note: Model ADR220-B175 data is not listed online, but we have a\n",
    "# spec sheet available on request \n",
    "generator = {\n",
    "    'torque_constant': 8.51,  # N*m/A\n",
    "    'winding_resistance': 5.87,  # Ω \n",
    "    'winding_inductance' : 0.0536,  # H \n",
    "    'max_torque': 137.9,  # N*m\n",
    "    'continuous_torque': 46,  # N*m\n",
    "    'max_speed': 150 * conv_s,  # rad/s\n",
    "    'MOI': 1.786e-2,  # kg*m^2 \n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We then define the PTO based on these part specifications. \n",
    "For Part 1, where we are setting up the problem, we will use the mid-size sprocket of diameter 127.3mm (8MX-50S-36). "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# drivetrain \n",
    "def gear_ratio(pulley_radius):\n",
    "    return 1/pulley_radius  # rad/m \n",
    "\n",
    "drivetrain_friction = 0.5  # N*m*s/rad  # this will be estimated experimentally in the future\n",
    "drivetrain_stiffness = 0  # N*m/rad \n",
    "# estimated based on mass, assumed to be a disk:\n",
    "idler_pulley['MOI'] = 0.5 * idler_pulley['mass'] * (idler_pulley['diameter']/2)**2  # kg*m^2\n",
    "\n",
    "# impedance model\n",
    "def pto_impedance(sprocket_model, omega=bem_data.omega.values):\n",
    "    pulley_ratio = sprockets[sprocket_model]['diameter'] / idler_pulley['diameter']\n",
    "    drivetrain_inertia = (\n",
    "        generator['MOI'] + \n",
    "        sprockets[sprocket_model]['MOI'] + \n",
    "        2 * idler_pulley['MOI']*pulley_ratio**2\n",
    "    )  # N*m^2\n",
    "    drivetrain_impedance = (\n",
    "        1j*omega*drivetrain_inertia + \n",
    "        drivetrain_friction + \n",
    "        1/(1j*omega)*drivetrain_stiffness\n",
    "    ) \n",
    "    winding_impedance = (generator['winding_resistance']\n",
    "                       + 1j*omega*generator['winding_inductance']\n",
    "    )\n",
    "    pulley_radius = sprockets[sprocket_model]['diameter'] / 2\n",
    "    pto_impedance_11 = -1* gear_ratio(pulley_radius)**2 * drivetrain_impedance\n",
    "    off_diag = -1*np.ones(omega.shape) * (\n",
    "        np.sqrt(3.0/2.0) * generator['torque_constant'] * gear_ratio(pulley_radius) + 0j)\n",
    "    pto_impedance_12 = off_diag \n",
    "    pto_impedance_21 = off_diag\n",
    "    pto_impedance_22 = winding_impedance\n",
    "    impedance = np.array([[pto_impedance_11, pto_impedance_12],\n",
    "                          [pto_impedance_21, pto_impedance_22]])\n",
    "    return impedance\n",
    "\n",
    "# PTO object\n",
    "name = [\"PTO_Heave\",]\n",
    "kinematics = np.array([[1, -1, 0, 0],])\n",
    "pto_ndof = 1\n",
    "controller = None\n",
    "loss = None\n",
    "default_sprocket = '8MX-50S-36'\n",
    "pto = wot.pto.PTO(pto_ndof,\n",
    "                  kinematics,\n",
    "                  controller,\n",
    "                  pto_impedance(default_sprocket),\n",
    "                  loss,\n",
    "                  name)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Constraints\n",
    "In this tutorial we include realistic constraints on both the device motions and the generator operation:\n",
    "\n",
    "* The **maximum stroke** (difference in heave between the float and spar) is 0.5m.\n",
    "Although there are end-stops (hard stop), the controller should ensure a soft stop.\n",
    "So, instead of modeling the hard stop we will add a constraint. \n",
    "* The generator has both a **maximum torque** and **maximum speed**.\n",
    "It is important that we do not exceed that during operation.\n",
    "* Generators also have a **continuous torque** requirement.\n",
    "The RMS torque during operation should not exceed this value or we risk damage to and failure of the machine.\n",
    "The torque can go higher that this (up to the maximum) for brief periods as long as the RMS torque remains below this threshold. \n",
    "\n",
    "We enforce all these through constraints on our design optimization problem. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "## Displacements\n",
    "# maximum stroke\n",
    "stroke_max = 0.5  # m\n",
    "def const_stroke_pto(wec, x_wec, x_opt, waves): \n",
    "    pos = pto.position(wec, x_wec, x_opt, waves, nsubsteps)\n",
    "    return stroke_max - np.abs(pos.flatten())\n",
    "\n",
    "## GENERATOR\n",
    "# peak torque\n",
    "default_radius = sprockets[default_sprocket]['diameter'] / 2\n",
    "def const_peak_torque_pto(wec, x_wec, x_opt, waves, radius=default_radius): \n",
    "    \"\"\"Instantaneous torque must not exceed max torque Tmax - |T| >=0 \n",
    "    \"\"\"\n",
    "    torque = pto.force(wec, x_wec, x_opt, waves, nsubsteps) / gear_ratio(radius)\n",
    "    return generator['max_torque'] - np.abs(torque.flatten())\n",
    "\n",
    "# continuous torque\n",
    "def const_torque_pto(wec, x_wec, x_opt, waves, radius=default_radius): \n",
    "    \"\"\"RMS torque must not exceed max continous torque \n",
    "        Tmax_conti - Trms >=0 \"\"\"\n",
    "    torque = pto.force(wec, x_wec, x_opt, waves, nsubsteps) / gear_ratio(radius)\n",
    "    torque_rms = np.sqrt(np.mean(torque.flatten()**2))\n",
    "    return generator['continuous_torque'] - torque_rms\n",
    "\n",
    "# max speed\n",
    "def const_speed_pto(wec, x_wec, x_opt, waves, radius=default_radius): \n",
    "    rot_vel = pto.velocity(wec, x_wec, x_opt, waves, nsubsteps) * gear_ratio(radius)\n",
    "    return generator['max_speed'] - np.abs(rot_vel.flatten())\n",
    "\n",
    "## Constraints\n",
    "constraints = [\n",
    "    {'type': 'ineq', 'fun': const_stroke_pto},\n",
    "    {'type': 'ineq', 'fun': const_peak_torque_pto},\n",
    "    {'type': 'ineq', 'fun': const_torque_pto},\n",
    "    {'type': 'ineq', 'fun': const_speed_pto},\n",
    "]\n",
    "nsubsteps = 5"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Mooring system\n",
    "To fully capture the dynamics acting on LUPA in the Large Wave Flume, we must model the mooring system being used to account for the restoring forces acting on the WEC.\n",
    "The LUPA setup uses a 4-line taut mooring system with springs connecting the spar to the wall of the wave flume.\n",
    "The following mooring system properties have been provided by Oregon State University.\n",
    "The initial fairlead coordinates and anchor coordinates are relative to the center of gravity of the combined device:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "pretension = 285 # N\n",
    "init_fair_coords = np.array([[-0.19, -0.19, -0.228],\n",
    "                             [-0.19,  0.19, -0.228],\n",
    "                             [ 0.19, -0.19, -0.228],\n",
    "                             [ 0.19,  0.19, -0.228]]) # m\n",
    "anch_coords = np.array([[-1.95, -1.6, -0.368],\n",
    "                        [-1.95,  1.6, -0.368],\n",
    "                        [ 1.95, -1.6, -0.368],\n",
    "                        [ 1.95,  1.6, -0.368]]) # m\n",
    "line_ax_stiff = 963. # N/m"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "There are several analytical and numerical methods commonly used to model mooring system kinematics for offshore systems, ranging from static analysis to determine equilibrium forces, all the way to FEA used to calculate the fully dynamic response of the mooring system components.\n",
    "For this design problem, we are mostly concerned with modeling the correct response of LUPA due to operational waves, so the high-fidelity methods are unnecessary at this design stage.\n",
    "While a purely linearized approach is common here, the symmetry of the taut lines in this current system allows us to instead use an analytical solution derived by Al-Solihat and Nahon ([link](https://doi.org/10.1080/17445302.2015.1089052)), which allows us to capture nonlinear mooring effects and off-diagonal terms in the mooring stiffness matrix without any significant increase in computation time.\n",
    "\n",
    "This solution takes an exact analysis of the derivatives of the classic elastic catenary equations and simplifies them by assuming the taut lines have no sag and negligible mass, allowing for the differential changes of the horizontal and vertical restoring force to be calculated as\n",
    "\n",
    "$$ \\frac{\\partial F_{hor}}{\\partial l} = K_{axial}\\textup{cos}^2 \\theta + \\frac{T}{L} \\textup{sin}^2 \\theta $$\n",
    "$$ \\frac{\\partial F_{vert}}{\\partial h} = K_{axial}\\textup{sin}^2 \\theta + \\frac{T}{L} \\textup{cos}^2 \\theta $$\n",
    "$$ \\frac{\\partial F_{hor}}{\\partial h} = \\frac{\\partial F_{vert}}{\\partial l} = \\textup{cos} \\theta \\textup{sin} \\theta \\left [ K_{axial}- \\frac{T}{L}\\right ]$$\n",
    "\n",
    "where $l$ and $h$ are the horizontal and vertical distance between the anchor points and fairlead points, respectively; $T$ is the pretension; $\\theta$ is the angle between the seabed and the mooring line such that\n",
    "\n",
    "$$ \\theta = \\textup{tan}^{-1}(\\frac{h}{l}) $$\n",
    "\n",
    "and $L$ is the stretched length of the mooring line such that\n",
    "\n",
    "$$ L = \\sqrt{l^2 + h^2} $$\n",
    "\n",
    "When these equations are applied to the linear stiffness equation in each radiating ($i$) and influencing ($j$) degrees of freedom:\n",
    "\n",
    "$$\\boldsymbol{K_{mooring}} = - \\frac{\\partial \\boldsymbol{F_{mooring}}}{\\partial \\boldsymbol{X}} \\\\\n",
    "= \\sum_{m=1}^{n_{lines}}  [K_{ij}]^{(m)} = - \\sum_{m=1}^{n_{lines}}[\\frac{\\partial (F_{mooring})_i}{\\partial X_j}]^{(m)} $$\n",
    "\n",
    "where $X$ are the generalized displacements of the WEC in each degree of freedom, they yield Equation (27) from the reference above which provides an analytical solution to the mooring stiffness matrix, which translates to the `k_mooring` function below.\n",
    "See the reference above for the full theoretical explanation and derivation of these equations."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# mooring matrix\n",
    "def k_mooring(fair_coords, anch_coords, pretension, k_ax, nlines):\n",
    "    \"\"\"Calculates the 7DOF effective stiffness matrix of a symmetric taut\n",
    "    mooring system using an analytical solution.\n",
    "    \"\"\"\n",
    "\n",
    "    theta = np.arctan(\n",
    "        (fair_coords[2] - anch_coords[2])**2\n",
    "      / np.sqrt(((fair_coords[0] - anch_coords[0])**2\n",
    "               + (fair_coords[1] - anch_coords[1])**2)))\n",
    "    linelen = np.sqrt((fair_coords[0] - anch_coords[0])**2\n",
    "                + (fair_coords[1] - anch_coords[1])**2\n",
    "                + (fair_coords[2] - anch_coords[2])**2)\n",
    "    fair_r = np.sqrt(fair_coords[0]**2 + fair_coords[1]**2)\n",
    "    fair_z = -fair_coords[2]\n",
    "    k_hh = 0.5 * nlines * (\n",
    "        pretension / linelen * (1 + np.sin(theta)**2)\n",
    "        + k_ax * np.cos(theta)**2)\n",
    "    k_rh = nlines * (\n",
    "        pretension / (2*linelen) * (fair_z * (1 + np.sin(theta)**2)\n",
    "        + fair_r * np.sin(theta) * np.cos(theta))\n",
    "        + 0.5 * k_ax * (fair_z * np.cos(theta)**2\n",
    "        - fair_r * np.sin(theta) * np.cos(theta)))\n",
    "    k_vv = nlines * (pretension / linelen *\n",
    "        np.cos(theta)**2 + k_ax * np.sin(theta)**2)\n",
    "    k_rr = nlines * (\n",
    "        pretension * (fair_z * np.sin(theta) + 0.5 * fair_r * np.cos(theta))\n",
    "        + (0.5 * pretension / linelen * ((fair_r * np.cos(theta) + fair_z * np.sin(theta))**2\n",
    "        + fair_z**2))\n",
    "        + 0.5 * k_ax * (fair_z * np.cos(theta) - fair_r*np.sin(theta))**2)\n",
    "    k_tt = nlines * (\n",
    "        pretension * fair_r / linelen * (fair_r + linelen*np.cos(theta)))\n",
    "    mat = np.zeros([7, 7])\n",
    "    mat[1, 1] = k_vv\n",
    "    mat[2, 2] = k_hh\n",
    "    mat[3, 3] = k_hh\n",
    "    mat[4, 4] = k_rr\n",
    "    mat[5, 5] = k_rr\n",
    "    mat[6, 6] = k_tt\n",
    "    mat[2, 5] = -k_rh\n",
    "    mat[5, 2] = -k_rh\n",
    "    mat[4, 3] = k_rh\n",
    "    mat[3, 4] = k_rh\n",
    "\n",
    "    return mat"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "`k_mooring` defines the 7x7 mooring matrix for a two-body point absorber WEC.\n",
    "Since we are only concerned with the planar components here, we can extract the rows/columns for the heaves, surge, and pitch to obtain the 4x4 matrix we need here."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "M = k_mooring(init_fair_coords[0, :], anch_coords[0, :], pretension,\n",
    "              line_ax_stiff, init_fair_coords.shape[0])\n",
    "ind_4dof = np.array([0, 1, 2, 5])\n",
    "M_4dof = M[np.ix_(ind_4dof, ind_4dof)]\n",
    "print(M_4dof)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Finally, with some more formatting, we can translate the mooring force into the format expected from WecOptTool by treating the mooring matrix as a transfer function and defining it via the `wecopttool.force_from_rao_transfer_function()` function, which multiplies the position of the WEC by the mooring matrix and return the restoring force."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# mooring\n",
    "M = xr.DataArray(M_4dof,\n",
    "                 coords=[bem_data.coords['influenced_dof'],\n",
    "                 bem_data.coords['radiating_dof']],\n",
    "                 dims=['influenced_dof', 'radiating_dof'])\n",
    "moor = ((M + 0j).expand_dims({\"omega\": bem_data.omega}))\n",
    "tmp = moor.isel(omega=0).copy(deep=True)\n",
    "tmp['omega'] = tmp['omega'] * 0\n",
    "moor = xr.concat([tmp, moor], dim='omega') \n",
    "moor = moor.transpose('omega', 'radiating_dof', 'influenced_dof')\n",
    "moor = -1*moor  # RHS of equation: -ma = Σf \n",
    "mooring_force = wot.force_from_rao_transfer_function(moor, True)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "#### Pretension of spar\n",
    "\n",
    "The spar is positively buoyant at its equilibrium position and relies on pretension from the mooring. \n",
    "The mooring matrix above only captures the restoring forces from the mooring lines, not the pretension itself.\n",
    "However, unlike Tutorial 2, we can ignore modeling this; WecOptTool assumes the device is starting in equilibrium, thus the pretension force is implied.\n",
    "We modeled this in Tutorial 2 because that optimization problem (comparing the hull mass vs. pretension) required relevant constraints on the mooring/tether line, so we had to explicitly model the buoyancy, gravity, and pretension force there to make those constraints possible.\n",
    "These forces have no impact on the solution to the optimization problem of interest in Part 2 of this tutorial (optimal sprocket sizing), so we can ignore them here."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### WEC object\n",
    "\n",
    "We are now ready to create our full WEC object. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# additional forces\n",
    "f_add = {\n",
    "    'PTO': pto.force_on_wec,\n",
    "    'Mooring': mooring_force\n",
    "}\n",
    "\n",
    "# small amount of friction to avoid small/negative terms\n",
    "friction = np.diag([2.0, 2.0, 2.0, 0])\n",
    "\n",
    "# WEC\n",
    "wec = wot.WEC.from_bem(bem_data,\n",
    "                       constraints=constraints,\n",
    "                       friction=friction,\n",
    "                       f_add=f_add,\n",
    "                       dof_names=bem_data.influenced_dof.values,\n",
    ")"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Solve\n",
    "We now solve the inner optimization for optimal control strategy for a fixed design.\n",
    "\n",
    "In a formal design case, it is good practice to first test the setup with a regular wave case to confirm the WEC is responding as expected.\n",
    "We have performed this step, but skip it here for the sake of brevity.\n",
    "To run the regular wave, change the wave selection in the code below. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Objective function\n",
    "obj_fun = pto.average_power\n",
    "nstate_opt = wec.ncomponents\n",
    "\n",
    "# Solve\n",
    "scale_x_wec = 1e1\n",
    "scale_x_opt = 1e-3\n",
    "scale_obj = 1e-2\n",
    "\n",
    "results = wec.solve(\n",
    "    waves['south_max_occurrence'], #waves['regular'],\n",
    "    obj_fun, \n",
    "    nstate_opt, \n",
    "    scale_x_wec=scale_x_wec,\n",
    "    scale_x_opt=scale_x_opt,\n",
    "    scale_obj=scale_obj,\n",
    ")\n",
    "power_results = [result.fun for result in results]\n",
    "print(f'Optimal average electrical power: {np.mean(power_results)} W')"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Post-process\n",
    "nsubsteps = 5\n",
    "wec_fdom, wec_tdom = wec.post_process(wec, results, waves['south_max_occurrence'], nsubsteps)\n",
    "pto_fdom, pto_tdom = pto.post_process(wec, results, waves['south_max_occurrence'], nsubsteps)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Results\n",
    "The `post_process` functions return lists of post-processed results. Here, we extract the first element of each list to analyze the results for the first wave phase realization. Looking at the response of the optimal solution, we can see the behavior of the WEC and its relationship to our problem constraints:\n",
    "\n",
    "* __PTO position__ - The PTO position corresponds to the difference in the vertical position between the two bodies.\n",
    "The PTO position is clearly nowhere near the 0.5 m maximum stroke, so the constraint is not plotted here.\n",
    "* __Excitation force and velocity__ - Much like Tutorial 2, we would expect the excitation force and velocity of each body to be in phase when maximizing for mechanical power and in the absence of constraints.\n",
    "Given the constraints on the PTO, this is not the case here, with the spar velocity being out of phase with the wave excitation acting on it.\n",
    "This indicates the differences when maximizing for mechanical vs. electrical power for LUPA in these wave conditions.\n",
    "It is also clear that the velocities (or their rotational equivalents) are nowhere near the generator maximum speed.\n",
    "* __Generator torque__ - This plot shows that both of the torque constraints are active for this wave case, and dominate the solution given the lack of relevance of the other constraints above.\n",
    "The PTO RMS torque is well within the continuous torque limit, and the generator exceeds the RMS limit for only brief period.\n",
    "The peak torque limit is approached at a few moments as well.\n",
    "* __Power__ - As expected, the greatest power absorption aligns with the times of greatest PTO velocity and peak torque magnitude. "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fig_res1, ax_res1 = plt.subplots(nrows=4, sharex=True, figsize=(8, 10))\n",
    "\n",
    "## PTO position\n",
    "wec_tdom[0].pos.sel(influenced_dof='spar__Heave').plot(\n",
    "    ax=ax_res1[0], linestyle='dashed', color='C7', label='Spar')\n",
    "wec_tdom[0].pos.sel(influenced_dof='float__Heave').plot(\n",
    "    ax=ax_res1[0], linestyle='dotted', color='C6', label='Float')\n",
    "pto_tdom[0].pos.plot(ax=ax_res1[0], label='PTO', color='black')\n",
    "\n",
    "ax_res1[0].set_ylabel('Position [m]')\n",
    "ax_res1[0].set_title('PTO position vs. WEC body position', fontweight='bold')\n",
    "ax_res1[0].legend(ncols=3, loc='lower center', frameon=False)\n",
    "ax_res1[0].grid(color='0.75', linestyle='-', linewidth=0.5, axis='x')\n",
    "ax_res1[0].set_xlabel('')\n",
    "ax_res1[0].set_ylim(bottom=ax_res1[0].get_ylim()[0]*1.33)\n",
    "\n",
    "## Excitation and velocity\n",
    "twinax = ax_res1[1].twinx()\n",
    "\n",
    "# Spar excitation\n",
    "force_excitation_spar = wec_tdom[0].force.sel(\n",
    "    influenced_dof='spar__Heave', type=['Froude_Krylov', 'diffraction'])\n",
    "force_excitation_spar = force_excitation_spar.sum('type')\n",
    "plt1 = force_excitation_spar.plot(\n",
    "    ax=ax_res1[1], linestyle='dashed', color='C0', label='Spar exc.')\n",
    "\n",
    "# Float excitation\n",
    "force_excitation_float = wec_tdom[0].force.sel(\n",
    "    influenced_dof='float__Heave', type=['Froude_Krylov', 'diffraction'])\n",
    "force_excitation_float = force_excitation_float.sum('type')\n",
    "plt2 = force_excitation_float.plot(\n",
    "    ax=ax_res1[1], linestyle='dotted', color='C0', label='Float exc.')\n",
    "\n",
    "# Spar/float velocity\n",
    "plt3 = wec_tdom[0].vel.sel(influenced_dof='spar__Heave').plot(\n",
    "    ax=twinax, color='C1', linestyle='dashed', label='Spar velocity')\n",
    "plt4 = wec_tdom[0].vel.sel(influenced_dof='float__Heave').plot(\n",
    "    ax=twinax, color='C1', linestyle='dotted', label='Float velocity')\n",
    "\n",
    "twinax.set_ylabel('Velocity [m/s]', color='C1')\n",
    "twinax.tick_params(axis='y', labelcolor='C1')\n",
    "twinax.set_title('')\n",
    "twinax.autoscale(enable=True, axis='x', tight=False)\n",
    "ax_res1[1].set_ylabel('Excitation force [N]', color='C0')\n",
    "ax_res1[1].tick_params(axis='y', labelcolor='C0')\n",
    "plts = plt1 + plt2 + plt3 + plt4\n",
    "ax_res1[1].legend(plts, [pl.get_label() for pl in plts], ncols=4, loc='lower center', frameon=False)\n",
    "ax_res1[1].set_title('WEC heave velocities vs. wave excitation', fontweight='bold')\n",
    "ax_res1[1].grid(color='0.75', linestyle='-', linewidth=0.5, axis='x')\n",
    "ax_res1[1].set_xlabel('')\n",
    "ax_res1[1].set_ylim(bottom=ax_res1[1].get_ylim()[0]*1.25)\n",
    "twinax.set_ylim(bottom=twinax.get_ylim()[0]*1.25)\n",
    "\n",
    "## Torque\n",
    "pto_tdom[0].force.plot(\n",
    "    ax=ax_res1[2], linestyle='solid', color='black', label='PTO trq.')\n",
    "pto_rms_tq  = np.sqrt(np.mean(pto_tdom[0].force.values**2)\n",
    "                    / pto_tdom[0].time.values[-1])\n",
    "ax_res1[2].plot(\n",
    "    pto_tdom[0].time, pto_rms_tq * np.ones(pto_tdom[0].time.shape),\n",
    "    color='C9', linestyle='solid', label='PTO RMS trq.')\n",
    "max_tq = generator['max_torque']\n",
    "rms_tq = generator['continuous_torque']\n",
    "ax_res1[2].plot(\n",
    "    pto_tdom[0].time, 1*max_tq * np.ones(pto_tdom[0].time.shape),\n",
    "    color='C5', linestyle='dotted', label=f'Peak trq. limit')\n",
    "ax_res1[2].plot(\n",
    "    pto_tdom[0].time, -1*max_tq * np.ones(pto_tdom[0].time.shape),\n",
    "    color='C5', linestyle='dotted')\n",
    "ax_res1[2].plot(\n",
    "    pto_tdom[0].time, 1*rms_tq * np.ones(pto_tdom[0].time.shape),\n",
    "    color='C9', linestyle='dotted', label=f'RMS trq. limit')\n",
    "ax_res1[2].plot(\n",
    "    pto_tdom[0].time, -1*rms_tq * np.ones(pto_tdom[0].time.shape),\n",
    "    color='C9', linestyle='dotted')\n",
    "ax_res1[2].set_ylabel('Torque [Nm] ')\n",
    "ax_res1[2].legend(ncols=4, loc='lower center', frameon=False)\n",
    "ax_res1[2].set_title('PTO torque response', fontweight='bold')\n",
    "ax_res1[2].grid(color='0.75', linestyle='-', linewidth=0.5, axis='x')\n",
    "ax_res1[2].set_xlabel('')\n",
    "ax_res1[2].set_ylim(bottom=ax_res1[2].get_ylim()[0]*1.5)\n",
    "\n",
    "## Power\n",
    "(pto_tdom[0]['power'].loc['mech',:,:]).plot(\n",
    "    ax=ax_res1[3], color='C8', label='Mech. power')\n",
    "(pto_tdom[0]['power'].loc['elec',:,:]).plot(\n",
    "    ax=ax_res1[3], color='C5', linestyle='dashed', label=\"Elec. power\")\n",
    "ax_res1[3].legend(ncols=2, loc='lower center', frameon=False)\n",
    "ax_res1[3].set_title('Power generation', fontweight='bold')\n",
    "ax_res1[3].grid(color='0.75', linestyle='-', linewidth=0.5, axis='x')\n",
    "ax_res1[3].set_ylabel('Power [W]')\n",
    "ax_res1[3].set_ylim(bottom=ax_res1[3].get_ylim()[0]*1.15)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "We can also look at all four degrees of freedom and make sure the relationships between the forces in each direction are reasonable.\n",
    "We can see that the PTO and radiation forces are generally in phase in the heave direction, but inversely related for the spar.\n",
    "We also see that the mooring response is inversely propotional to the radiation forces of the spar (with a more delayed restoring response in pitch than in surge/heave), and that the mooring correctly has no effect on the float, which it does not connect to."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "influenced_dofs = bem_data.influenced_dof.values\n",
    "## Forces\n",
    "fig_res2, ax_res2 = plt.subplots(len(influenced_dofs), 1, sharex=True, figsize=(8, 10))\n",
    "for j, idof in enumerate(influenced_dofs):\n",
    "    force_excitation = wec_tdom[0].force.sel(\n",
    "        type=['Froude_Krylov', 'diffraction'])\n",
    "    force_excitation = force_excitation.sum('type')\n",
    "    force_excitation.sel(influenced_dof=idof).plot(\n",
    "        ax=ax_res2[j], label='Excitation')\n",
    "    wec_tdom[0].force.sel(influenced_dof=idof, type='radiation').plot(\n",
    "        ax=ax_res2[j], label='Radiation')\n",
    "    wec_tdom[0].force.sel(influenced_dof=idof, type='hydrostatics').plot(\n",
    "        ax=ax_res2[j], label='Hydrostatics')\n",
    "    wec_tdom[0].force.sel(influenced_dof=idof, type='Mooring').plot(\n",
    "        ax=ax_res2[j], label='Mooring')\n",
    "    wec_tdom[0].force.sel(influenced_dof=idof, type='PTO').plot(\n",
    "        ax=ax_res2[j], label='PTO')\n",
    "    ax_res2[j].set_title(f'{idof}')\n",
    "    if j != len(influenced_dofs)-1:\n",
    "        ax_res2[j].set_xlabel('')\n",
    "    ax_res2[j].grid(color='0.75', linestyle='-', linewidth=0.5, axis='x')\n",
    "handles_res2, labels_res2 = ax_res2[j].get_legend_handles_labels()\n",
    "fig_res2.legend(handles_res2, labels_res2, loc=(0.105, 0.02), ncol=5, frameon=False)\n",
    "fig_res2.suptitle('WEC Forces', fontweight='bold', y=0.93)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## 2. Control co-design of the PTO sprocket sizing for maximum electrical power\n",
    "\n",
    "### Setup\n",
    "With our model working as expected, we can now iterate on this model with varying sprocket sizing to identify the optimal size.\n",
    "As with previous tutorials, we wrap the code from Part 1 into a function and iterate on our chosen design parameter (i.e. each key of the `sprockets` dictionary earlier corresponds to the `x` argument of `design_obj_fun`):"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def design_obj_fun(x):\n",
    "    global n\n",
    "    n += 1\n",
    "\n",
    "    # Unpack sprocket name\n",
    "    x = x.squeeze()\n",
    "    sprocket = list(sprockets.keys())[x]\n",
    "    spr_rad = sprockets[sprocket]['diameter'] / 2\n",
    "    spr_mass = sprockets[sprocket]['mass']\n",
    "    spr_moi = sprockets[sprocket]['MOI']\n",
    "    spr_des = sprockets[sprocket]['design']\n",
    "\n",
    "    # PTO object for given sprocket\n",
    "    pto = wot.pto.PTO(pto_ndof, kinematics, controller, pto_impedance(sprocket), loss, name)\n",
    "    \n",
    "    ## Constraints\n",
    "    # Maximum stroke\n",
    "    stroke_max = 0.5  # m\n",
    "    def const_stroke_pto(wec, x_wec, x_opt, waves): \n",
    "        pos = pto.position(wec, x_wec, x_opt, waves, nsubsteps)\n",
    "        return stroke_max - np.abs(pos.flatten())\n",
    "\n",
    "    ## GENERATOR\n",
    "    # peak torque\n",
    "    radius = sprockets[sprocket]['diameter'] / 2\n",
    "    def const_peak_torque_pto(wec, x_wec, x_opt, waves): \n",
    "        \"\"\"Instantaneous torque must not exceed max torque Tmax - |T| >=0 \n",
    "        \"\"\"\n",
    "        torque = pto.force(wec, x_wec, x_opt, waves, nsubsteps) / gear_ratio(radius)\n",
    "        return generator['max_torque'] - np.abs(torque.flatten())\n",
    "\n",
    "    # continuous torque\n",
    "    def const_torque_pto(wec, x_wec, x_opt, waves): \n",
    "        \"\"\"RMS torque must not exceed max continous torque \n",
    "            Tmax_conti - Trms >=0 \"\"\"\n",
    "        torque = pto.force(wec, x_wec, x_opt, waves, nsubsteps) / gear_ratio(radius)\n",
    "        torque_rms = np.sqrt(np.mean(torque.flatten()**2))\n",
    "        return generator['continuous_torque'] - torque_rms\n",
    "\n",
    "    # max speed\n",
    "    def const_speed_pto(wec, x_wec, x_opt, waves): \n",
    "        rot_vel = pto.velocity(wec, x_wec, x_opt, waves, nsubsteps) * gear_ratio(radius)\n",
    "        return generator['max_speed'] - np.abs(rot_vel.flatten())\n",
    "\n",
    "    ## Constraints\n",
    "    constraints = [\n",
    "        {'type': 'ineq', 'fun': const_stroke_pto},\n",
    "        {'type': 'ineq', 'fun': const_peak_torque_pto},\n",
    "        {'type': 'ineq', 'fun': const_torque_pto},\n",
    "        {'type': 'ineq', 'fun': const_speed_pto},\n",
    "    ]\n",
    "\n",
    "    # additional forces\n",
    "    f_add = {\n",
    "        'PTO': pto.force_on_wec,\n",
    "        'Mooring': mooring_force\n",
    "    }\n",
    "\n",
    "    # create WEC object\n",
    "    wec = wot.WEC.from_bem(bem_data,\n",
    "                           constraints=constraints,\n",
    "                           friction=friction,\n",
    "                           f_add=f_add,\n",
    "    )\n",
    "\n",
    "    # Objective function\n",
    "    obj_fun = pto.average_power \n",
    "\n",
    "    print(\n",
    "        f'\\nRun {n} of {N}: Sprocket {sprocket}\\n' +\n",
    "        f'   Sprocket diameter: {spr_rad*2} m\\n' +\n",
    "        f'   Sprocket mass: {spr_mass} kg\\n' +\n",
    "        f'   Sprocket moment of inertia: {spr_moi} kg-m^2\\n' +\n",
    "        f'   Sprocket design: {spr_des}')\n",
    "\n",
    "    results = wec.solve(\n",
    "        waves['south_max_occurrence'], #waves['regular'],\n",
    "        obj_fun, \n",
    "        nstate_opt, \n",
    "        scale_x_wec=scale_x_wec,\n",
    "        scale_x_opt=scale_x_opt,\n",
    "        scale_obj=scale_obj,\n",
    "    )\n",
    "    print(f'Optimal average electrical power: {results[0].fun:.2f} W')\n",
    "    x_wec, x_opt = wec.decompose_state(results[0].x)\n",
    "    x_wec_jac , x_opt_jac = wec.decompose_state(results[0].jac)\n",
    "    ds = xr.Dataset(data_vars=dict(\n",
    "        x_wec=('wec_state', x_wec),\n",
    "        x_opt=('opt_state', x_opt),\n",
    "        x_wec_jac=('wec_state', x_wec_jac),\n",
    "        x_opt_jac=('opt_state', x_opt_jac),\n",
    "        fval=results[0].fun),\n",
    "        coords=dict(\n",
    "        wec_state=range(wec.nstate_wec),\n",
    "        opt_state=range(nstate_opt))\n",
    "    )\n",
    "    wot.write_netcdf(os.path.join(dir, 'data', f'tutorial_3_results_{x}.nc'), ds)\n",
    "    return results[0].fun"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Given there are only 22 sprockets, we will continue to use a brute force algorithm.\n",
    "This algorithm typically takes several hours to run; for sake of time here, we have included the calculated results in the `tutorial_3_results.nc` file.\n",
    "If you would like to run the brute force algorithm yourself (e.g. if you modify this notebook and would like to see how the results change), move or delete this file from the `data` directory."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "global n; n = 0 \n",
    "global N; N = len(sprockets)\n",
    "ranges = slice(0, N, 1),\n",
    "\n",
    "# solve\n",
    "filename = 'data/tutorial_3_results.nc'\n",
    "try:\n",
    "    opt_results = wot.read_netcdf(filename)\n",
    "except:\n",
    "    combined_results = []\n",
    "    _ = brute(\n",
    "        func=design_obj_fun,\n",
    "        ranges=ranges,\n",
    "        full_output=True,\n",
    "        finish=None)\n",
    "    for x in range(N):\n",
    "        run_filename = os.path.join(dir, 'data', f'tutorial_3_results_{x}.nc')\n",
    "        combined_results.append(wot.read_netcdf(run_filename))\n",
    "        os.remove(run_filename)\n",
    "    opt_results = xr.concat(combined_results, dim='x0s')\n",
    "    wot.write_netcdf(filename, opt_results)"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "### Results\n",
    "The power generation for all the sprockets are plotted below, with the three sprockets possessed by Oregon State University called out.\n",
    "Comparing the results across the range of sprocket sizes, it is clear that power generation is maximized towards smaller sprocket diameters.\n",
    "Here, 8MX-33S-36 sprocket (the second smallest diameter) is the best sprocket selection for LUPA for the selected wave case.\n",
    "\n",
    "The motivation to include an interchangeable sprocket in LUPA is to make it versatile across different locations and wave conditions.\n",
    "The optimal sprocket could be different when tested with a more or less severe wave climate, or a different mooring configuration.\n",
    "Try moving the `data/tutorial_3_results.nc` file as above, and test different `wave_cases` keys or modify the mooring system parameters (`init_fair_coords`, `anch_coords`, `line_ax_stiff`, and `pretension`) and see how the WEC response changes and which sprocket generates the most power."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "spr_names = list(sprockets.keys())\n",
    "spr_diameters = np.zeros(len(spr_names))\n",
    "for i, spr in enumerate(spr_names):\n",
    "    spr_diameters[i] = sprockets[spr]['diameter']"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "fvals = opt_results.fval.values\n",
    "opt_x0 = np.argmin(fvals)\n",
    "fig1, ax1 = plt.subplots()\n",
    "ax1.grid()\n",
    "ax1.plot(spr_diameters, fvals, 'k', zorder=0)\n",
    "ax1.scatter(spr_diameters, fvals, zorder=1)\n",
    "ax1.scatter(spr_diameters[opt_x0], fvals[opt_x0])\n",
    "ax1.set_xlabel('Sprocket diameter [m]')\n",
    "ax1.set_ylabel('Power [W]')\n",
    "ax1.set_title('Design optimization results vs. sprocket diameter', fontweight='bold')\n",
    "osu_sprockets = ['8MX-32S-36', '8MX-50S-36', '8MX-80S-36']\n",
    "for i, spr in enumerate(spr_names):\n",
    "    if spr in spr_names[int(opt_x0.squeeze())]:\n",
    "        ax1.annotate(\n",
    "            spr,\n",
    "            xy=(spr_diameters[i], fvals[i]),\n",
    "            xytext=(50, -3.5),\n",
    "            textcoords='offset points',\n",
    "            bbox=dict(boxstyle='square', fc='0.8'),\n",
    "            arrowprops=dict(arrowstyle='->', facecolor='black'))\n",
    "    elif spr in osu_sprockets:\n",
    "        ax1.annotate(spr,\n",
    "        xy=(spr_diameters[i],\n",
    "        fvals[i]),\n",
    "        xytext=(40, 20),\n",
    "        textcoords='offset points',\n",
    "        arrowprops=dict(arrowstyle='->', facecolor='black'))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "wot_dev",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.4"
  },
  "vscode": {
   "interpreter": {
    "hash": "a3e13d9eb6391ec8c830b5b864d7e2cac256aef786c5e95ba02dc5258710976f"
   }
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
