

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>wecopttool.core &mdash; WecOptTool 3.0.2 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom.css?v=a0fb6060" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=3f474186"></script>
      <script src="../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            WecOptTool
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../theory.html">Theory &amp; Practice</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../implementation.html">Implementation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">References</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api_docs/wecopttool.html">API Documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">WecOptTool</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
          <li class="breadcrumb-item"><a href="../wecopttool.html">wecopttool</a></li>
      <li class="breadcrumb-item active">wecopttool.core</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for wecopttool.core</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Core functionality for solving the pseudo-spectral problem for WEC.</span>

<span class="sd">Contains:</span>

<span class="sd">* The *WEC* class</span>
<span class="sd">* Functions for basic functionality</span>

<span class="sd">.. note:: All contents of this module are imported into *WecOpTool* and</span>
<span class="sd">          can be called directly as :python:`wecopttool.&lt;function&gt;`</span>
<span class="sd">          instead of :python:`wecopttool.core.&lt;function&gt;`.</span>
<span class="sd">&quot;&quot;&quot;</span>


<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;WEC&quot;</span><span class="p">,</span>
    <span class="s2">&quot;ncomponents&quot;</span><span class="p">,</span>
    <span class="s2">&quot;frequency&quot;</span><span class="p">,</span>
    <span class="s2">&quot;time&quot;</span><span class="p">,</span>
    <span class="s2">&quot;time_mat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;derivative_mat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;derivative2_mat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;mimo_transfer_mat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;vec_to_dofmat&quot;</span><span class="p">,</span>
    <span class="s2">&quot;dofmat_to_vec&quot;</span><span class="p">,</span>
    <span class="s2">&quot;real_to_complex&quot;</span><span class="p">,</span>
    <span class="s2">&quot;complex_to_real&quot;</span><span class="p">,</span>
    <span class="s2">&quot;fd_to_td&quot;</span><span class="p">,</span>
    <span class="s2">&quot;td_to_fd&quot;</span><span class="p">,</span>
    <span class="s2">&quot;read_netcdf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;write_netcdf&quot;</span><span class="p">,</span>
    <span class="s2">&quot;check_radiation_damping&quot;</span><span class="p">,</span>
    <span class="s2">&quot;check_impedance&quot;</span><span class="p">,</span>
    <span class="s2">&quot;force_from_rao_transfer_function&quot;</span><span class="p">,</span>
    <span class="s2">&quot;force_from_impedance&quot;</span><span class="p">,</span>
    <span class="s2">&quot;force_from_waves&quot;</span><span class="p">,</span>
    <span class="s2">&quot;inertia&quot;</span><span class="p">,</span>
    <span class="s2">&quot;standard_forces&quot;</span><span class="p">,</span>
    <span class="s2">&quot;run_bem&quot;</span><span class="p">,</span>
    <span class="s2">&quot;change_bem_convention&quot;</span><span class="p">,</span>
    <span class="s2">&quot;add_linear_friction&quot;</span><span class="p">,</span>
    <span class="s2">&quot;wave_excitation&quot;</span><span class="p">,</span>
    <span class="s2">&quot;hydrodynamic_impedance&quot;</span><span class="p">,</span>
    <span class="s2">&quot;atleast_2d&quot;</span><span class="p">,</span>
    <span class="s2">&quot;degrees_to_radians&quot;</span><span class="p">,</span>
    <span class="s2">&quot;subset_close&quot;</span><span class="p">,</span>
    <span class="s2">&quot;scale_dofs&quot;</span><span class="p">,</span>
    <span class="s2">&quot;decompose_state&quot;</span><span class="p">,</span>
    <span class="s2">&quot;frequency_parameters&quot;</span><span class="p">,</span>
    <span class="s2">&quot;time_results&quot;</span><span class="p">,</span>
    <span class="s2">&quot;set_fb_centers&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Mapping</span><span class="p">,</span> <span class="n">TypeVar</span><span class="p">,</span> <span class="n">Union</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">datetime</span><span class="w"> </span><span class="kn">import</span> <span class="n">datetime</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">ArrayLike</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">autograd.numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">autograd.numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">ndarray</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">autograd.builtins</span><span class="w"> </span><span class="kn">import</span> <span class="nb">isinstance</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="nb">dict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">autograd</span><span class="w"> </span><span class="kn">import</span> <span class="n">grad</span><span class="p">,</span> <span class="n">jacobian</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">xr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">xarray</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">Dataset</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">capytaine</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">cpy</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.optimize</span><span class="w"> </span><span class="kn">import</span> <span class="n">minimize</span><span class="p">,</span> <span class="n">OptimizeResult</span><span class="p">,</span> <span class="n">Bounds</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">block_diag</span><span class="p">,</span> <span class="n">dft</span>


<span class="c1"># logger</span>
<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="c1"># autograd warnings</span>
<span class="n">filter_msg</span> <span class="o">=</span> <span class="s2">&quot;Casting complex values to real discards the imaginary part&quot;</span>
<span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">message</span><span class="o">=</span><span class="n">filter_msg</span><span class="p">)</span>

<span class="c1"># default values</span>
<span class="n">_default_parameters</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;rho&#39;</span><span class="p">:</span> <span class="mf">1025.0</span><span class="p">,</span> <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="mf">9.81</span><span class="p">,</span> <span class="s1">&#39;depth&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">}</span>
<span class="n">_default_min_damping</span> <span class="o">=</span> <span class="mf">1e-6</span>

<span class="c1"># type aliases</span>
<span class="n">TWEC</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;TWEC&quot;</span><span class="p">,</span> <span class="n">bound</span><span class="o">=</span><span class="s2">&quot;WEC&quot;</span><span class="p">)</span>
<span class="n">TStateFunction</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[</span>
    <span class="p">[</span><span class="n">TWEC</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">Dataset</span><span class="p">],</span> <span class="n">ndarray</span><span class="p">]</span>
<span class="n">TForceDict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TStateFunction</span><span class="p">]</span>
<span class="n">TIForceDict</span> <span class="o">=</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">TStateFunction</span><span class="p">]</span>
<span class="n">FloatOrArray</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ArrayLike</span><span class="p">]</span>


<div class="viewcode-block" id="WEC">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.html#wecopttool.WEC">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">WEC</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A wave energy converter (WEC) object for performing simulations</span>
<span class="sd">    using the pseudo-spectral solution method.</span>

<span class="sd">    To create the WEC use one of the initialization methods:</span>

<span class="sd">    * :py:meth:`wecopttool.WEC.__init__`</span>
<span class="sd">    * :py:meth:`wecopttool.WEC.from_bem`</span>
<span class="sd">    * :py:meth:`wecopttool.WEC.from_floating_body`</span>
<span class="sd">    * :py:meth:`wecopttool.WEC.from_impedance`.</span>

<span class="sd">    .. note:: Direct initialization of a :py:class:`wecopttool.WEC`</span>
<span class="sd">        object as :python:`WEC(f1, nfreq, forces, ...)` using</span>
<span class="sd">        :py:meth:`wecopttool.WEC.__init__` is discouraged. Instead</span>
<span class="sd">        use one of the other initialization methods listed in the</span>
<span class="sd">        *See Also* section.</span>

<span class="sd">    To solve the pseudo-spectral problem use</span>
<span class="sd">    :py:meth:`wecopttool.WEC.solve`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="WEC.__init__">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.html#wecopttool.WEC.__init__">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">f1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">forces</span><span class="p">:</span> <span class="n">TIForceDict</span><span class="p">,</span>
        <span class="n">constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inertia_matrix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">ndof</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">inertia_in_forces</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dof_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a WEC object directly from its inertia matrix and</span>
<span class="sd">        list of forces.</span>

<span class="sd">        The :py:class:`wecopttool.WEC` class describes a WEC&#39;s</span>
<span class="sd">        equation of motion as :math:`ma=Σf` where the</span>
<span class="sd">        :python:`inertia_matrix` matrix specifies the inertia :math:`m`,</span>
<span class="sd">        and the :python:`forces` dictionary specifies the different</span>
<span class="sd">        forces to be summed. The forces can be linear or nonlinear.</span>
<span class="sd">        If :python:`inertia_in_forces is True` the equation of motion is</span>
<span class="sd">        :math:`Σf=0`, which is included to allow for initialization</span>
<span class="sd">        using an intrinsic impedance through the</span>
<span class="sd">        :python:`WEC.from_impedance` initialization function.</span>

<span class="sd">        .. note:: Direct initialization of a</span>
<span class="sd">            :py:class:`wecopttool.WEC` object as</span>
<span class="sd">            :python:`WEC(f1, nfreq, forces, ...)` is discouraged.</span>
<span class="sd">            Instead use one of the other initialization methods listed</span>
<span class="sd">            in the *See Also* section.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        f1</span>
<span class="sd">            Fundamental frequency :python:`f1` [:math:`Hz`].</span>
<span class="sd">        nfreq</span>
<span class="sd">            Number of frequencies (not including zero frequency),</span>
<span class="sd">            i.e., :python:`freqs = [0, f1, 2*f1, ..., nfreq*f1]`.</span>
<span class="sd">        forces</span>
<span class="sd">            Dictionary with entries :python:`{&#39;force_name&#39;: fun}`,</span>
<span class="sd">            where :python:`fun` has a  signature</span>
<span class="sd">            :python:`def fun(wec, x_wec, x_opt, waves):`, and returns</span>
<span class="sd">            forces in the time-domain of size</span>
<span class="sd">            :python:`(2*nfreq+1, ndof)`.</span>
<span class="sd">        constraints</span>
<span class="sd">            List of constraints, see documentation for</span>
<span class="sd">            :py:func:`scipy.optimize.minimize` for description and</span>
<span class="sd">            options of constraints dictionaries.</span>
<span class="sd">            If :python:`None`: empty list :python:`[]`.</span>
<span class="sd">        inertia_matrix</span>
<span class="sd">           Inertia matrix of size :python:`(ndof, ndof)`.</span>
<span class="sd">           Not used if :python:`inertia_in_forces` is :python:`True`.</span>
<span class="sd">        ndof</span>
<span class="sd">            Number of degrees of freedom.</span>
<span class="sd">            Must be specified if :python:`inertia_in_forces is True`,</span>
<span class="sd">            else not used.</span>
<span class="sd">        inertia_in_forces</span>
<span class="sd">            Set to True if inertial &quot;forces&quot; are included in the</span>
<span class="sd">            :python:`forces` argument.</span>
<span class="sd">            This scenario is rare.</span>
<span class="sd">            If using an intrinsic impedance, consider initializing with</span>
<span class="sd">            :py:meth:`wecoptool.core.WEC.from_impedance` instead.</span>
<span class="sd">        dof_names</span>
<span class="sd">            Names of the different degrees of freedom (e.g.</span>
<span class="sd">            :python:`&#39;Heave&#39;`).</span>
<span class="sd">            If :python:`None` the names</span>
<span class="sd">            :python:`[&#39;DOF_0&#39;, ..., &#39;DOF_N&#39;]` are used.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If :python:`inertia_in_forces is True` but :python:`ndof` is</span>
<span class="sd">            not specified.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If :python:`inertia_in_forces is False` but</span>
<span class="sd">            :python:`inertia_matrix` is not specified.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If :python:`inertia_matrix` does not have the correct size</span>
<span class="sd">            (:python:`(ndof, ndof)`).</span>
<span class="sd">        ValueError</span>
<span class="sd">            If :python:`dof_names` does not have the correct size</span>
<span class="sd">            (:python:`ndof`).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        from_bem:</span>
<span class="sd">            Initialize a :py:class:`wecopttool.WEC` object from BEM</span>
<span class="sd">            results.</span>
<span class="sd">        from_floating_body:</span>
<span class="sd">            Initialize a :py:class:`wecopttool.WEC` object from a</span>
<span class="sd">            :py:class:`capytaine.bodies.bodies.FloatingBody` object.</span>
<span class="sd">        from_impedance:</span>
<span class="sd">            Initialize a :py:class:`wecopttool.WEC` object from an</span>
<span class="sd">            intrinsic impedance array and excitation coefficients.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">=</span> <span class="n">frequency</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_time_mat</span> <span class="o">=</span> <span class="n">time_mat</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_derivative_mat</span> <span class="o">=</span> <span class="n">derivative_mat</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_derivative2_mat</span> <span class="o">=</span> <span class="n">derivative2_mat</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_forces</span> <span class="o">=</span> <span class="n">forces</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span> <span class="k">if</span> <span class="p">(</span><span class="n">constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="n">constraints</span>

        <span class="c1"># inertia options</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_in_forces</span> <span class="o">=</span> <span class="n">inertia_in_forces</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_missing</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&#39; must be provided if &#39;inertia_in_forces&#39; is&quot;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">msg</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_ignored</span><span class="p">(</span><span class="n">var_name</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">var_name</span><span class="si">}</span><span class="s2">&#39; is not used when &#39;inertia_in_forces&#39; is &quot;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">condition</span><span class="si">}</span><span class="s2">&#39; and should not be provided&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">msg</span>

        <span class="k">if</span> <span class="n">inertia_in_forces</span><span class="p">:</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span>
            <span class="k">if</span> <span class="n">inertia_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_ignored</span><span class="p">(</span><span class="s2">&quot;inertia_matrix&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">))</span>
                <span class="n">inertia_matrix</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">ndof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_missing</span><span class="p">(</span><span class="s2">&quot;ndof&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">))</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">inertia_in_forces</span><span class="p">:</span>
            <span class="n">condition</span> <span class="o">=</span> <span class="s2">&quot;False&quot;</span>
            <span class="k">if</span> <span class="n">inertia_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">_missing</span><span class="p">(</span><span class="s2">&quot;inertia_matrix&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">))</span>
            <span class="n">inertia_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">inertia_matrix</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ndof</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">_ignored</span><span class="p">(</span><span class="s2">&quot;ndof&quot;</span><span class="p">,</span> <span class="n">condition</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">ndof</span> <span class="o">!=</span> <span class="n">inertia_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Provided value of &#39;ndof&#39; does not match size of &quot;</span> <span class="o">+</span>
                        <span class="s2">&quot;&#39;inertia_matrix&#39;. Setting &quot;</span> <span class="o">+</span>
                        <span class="sa">f</span><span class="s2">&quot;&#39;ndof=</span><span class="si">{</span><span class="n">inertia_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
            <span class="n">ndof</span> <span class="o">=</span> <span class="n">inertia_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">inertia_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="n">ndof</span><span class="p">,</span> <span class="n">ndof</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;&#39;inertia_matrix&#39; must be a square matrix of size equal &quot;</span> <span class="o">+</span>
                    <span class="s2">&quot;to the number of degrees of freedom.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_matrix</span> <span class="o">=</span> <span class="n">inertia_matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ndof</span> <span class="o">=</span> <span class="n">ndof</span>
        <span class="k">if</span> <span class="n">inertia_in_forces</span><span class="p">:</span>
            <span class="n">_inertia</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_inertia</span> <span class="o">=</span> <span class="n">inertia</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">inertia_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_inertia</span> <span class="o">=</span> <span class="n">_inertia</span>

        <span class="c1"># names</span>
        <span class="k">if</span> <span class="n">dof_names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dof_names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s1">&#39;DOF_</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s1">&#39;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndof</span><span class="p">)]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">dof_names</span><span class="p">)</span> <span class="o">!=</span> <span class="n">ndof</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;dof_names&#39; must have length &#39;ndof&#39;.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dof_names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dof_names</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="nb">str</span> <span class="o">=</span> <span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">: &#39;</span> <span class="o">+</span>
               <span class="sa">f</span><span class="s1">&#39;DOFs (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="si">}</span><span class="s1">)=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dof_names</span><span class="si">}</span><span class="s1">, &#39;</span> <span class="o">+</span>
               <span class="sa">f</span><span class="s1">&#39;f=[0, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f1</span><span class="si">}</span><span class="s1">, ..., </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="si">}</span><span class="s1">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">f1</span><span class="si">}</span><span class="s1">)] Hz.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">type_</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">module</span> <span class="o">=</span> <span class="n">type_</span><span class="o">.</span><span class="vm">__module__</span>
        <span class="n">qualname</span> <span class="o">=</span> <span class="n">type_</span><span class="o">.</span><span class="vm">__qualname__</span>
        <span class="n">repr_org</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="n">module</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">qualname</span><span class="si">}</span><span class="s2"> object at </span><span class="si">{</span><span class="nb">hex</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="k">return</span> <span class="n">repr_org</span> <span class="o">+</span> <span class="s2">&quot; :: &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="c1"># other initialization methods</span>
<div class="viewcode-block" id="WEC.from_bem">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.from_bem.html#wecopttool.WEC.from_bem">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_bem</span><span class="p">(</span>
        <span class="n">bem_data</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dataset</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">]],</span>
        <span class="n">friction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">f_add</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TIForceDict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_damping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">_default_min_damping</span><span class="p">,</span>
        <span class="n">uniform_shift</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">dof_names</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TWEC</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a WEC object from linear hydrodynamic coefficients</span>
<span class="sd">        obtained using the boundary element method (BEM) code Capytaine.</span>

<span class="sd">        The :python:`bem_data` can be a dataset or the name of a</span>
<span class="sd">        *NetCDF* file containing the dataset.</span>

<span class="sd">        The returned :py:class:`wecopttool.WEC` object contains the</span>
<span class="sd">        inertia and the default linear forces: radiation, diffraction,</span>
<span class="sd">        and Froude-Krylov. Additional forces can be specified through</span>
<span class="sd">        :python:`f_add`.</span>

<span class="sd">        Note that because Capytaine uses a different sign convention,</span>
<span class="sd">        the direct results from capytaine must be modified using</span>
<span class="sd">        :py:func:`wecopttool.change_bem_convention` before calling</span>
<span class="sd">        this initialization function.</span>
<span class="sd">        Instead, the recommended approach is to use</span>
<span class="sd">        :py:func:`wecopttool.run_bem`,</span>
<span class="sd">        rather than running Capytaine directly, which outputs the</span>
<span class="sd">        results in the correct convention. The results can be saved</span>
<span class="sd">        using :py:func:`wecopttool.write_netcdf`.</span>
<span class="sd">        :py:func:`wecopttool.run_bem` also computes the inertia and</span>
<span class="sd">        hydrostatic stiffness which should be included in bem_data.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bem_data</span>
<span class="sd">            Linear hydrodynamic coefficients obtained using the boundary</span>
<span class="sd">            element method (BEM) code Capytaine, with sign convention</span>
<span class="sd">            corrected. Also includes inertia and hydrostatic stiffness.</span>
<span class="sd">        friction</span>
<span class="sd">            Linear friction, in addition to radiation damping, of size</span>
<span class="sd">            :python:`(ndof, ndof)`.</span>
<span class="sd">            :python:`None` if included in :python:`bem_data` or to set</span>
<span class="sd">            to zero.</span>
<span class="sd">        f_add</span>
<span class="sd">            Dictionary with entries :python:`{&#39;force_name&#39;: fun}`, where</span>
<span class="sd">            :python:`fun` has a  signature</span>
<span class="sd">            :python:`def fun(wec, x_wec, x_opt, waves):`, and returns</span>
<span class="sd">            forces in the time-domain of size</span>
<span class="sd">            :python:`(2*nfreq+1, ndof)`.</span>
<span class="sd">        constraints</span>
<span class="sd">            List of constraints, see documentation for</span>
<span class="sd">            :py:func:`scipy.optimize.minimize` for description and</span>
<span class="sd">            options of constraints dictionaries.</span>
<span class="sd">            If :python:`None`: empty list :python:`[]`.</span>
<span class="sd">        min_damping</span>
<span class="sd">            Minimum damping level to ensure a stable system.</span>
<span class="sd">            See :py:func:`wecopttool.check_radiation_damping` for more details.</span>
<span class="sd">        uniform_shift</span>
<span class="sd">            Boolean determining whether damping corrections shifts the damping</span>
<span class="sd">            values uniformly for all frequencies or only for frequencies below</span>
<span class="sd">            :python:`min_damping`.</span>
<span class="sd">            See :py:func:`wecopttool.check_radiation_damping` for more details.</span>
<span class="sd">        dof_names</span>
<span class="sd">            Names of the different degrees of freedom (e.g.</span>
<span class="sd">            :python:`&#39;Heave&#39;`).</span>
<span class="sd">            If :python:`None` the names</span>
<span class="sd">            :python:`[&#39;DOF_0&#39;, ..., &#39;DOF_N&#39;]` are used.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        run_bem, add_linear_friction, change_bem_convention,</span>
<span class="sd">        write_netcdf, check_radiation_damping</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bem_data</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
            <span class="n">bem_data</span> <span class="o">=</span> <span class="n">read_netcdf</span><span class="p">(</span><span class="n">bem_data</span><span class="p">)</span>
        <span class="c1"># add friction</span>
        <span class="n">hydro_data</span> <span class="o">=</span> <span class="n">add_linear_friction</span><span class="p">(</span><span class="n">bem_data</span><span class="p">,</span> <span class="n">friction</span><span class="p">)</span>
        <span class="n">inertia_matrix</span> <span class="o">=</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;inertia_matrix&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>

        <span class="c1"># frequency array</span>
        <span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span> <span class="o">=</span> <span class="n">frequency_parameters</span><span class="p">(</span>
            <span class="n">hydro_data</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">values</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># check real part of damping diagonal &gt; 0</span>
        <span class="k">if</span> <span class="n">min_damping</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">hydro_data</span> <span class="o">=</span> <span class="n">check_radiation_damping</span><span class="p">(</span>
                <span class="n">hydro_data</span><span class="p">,</span> <span class="n">min_damping</span><span class="p">,</span> <span class="n">uniform_shift</span><span class="p">)</span>

        <span class="c1"># forces in the dynamics equations</span>
        <span class="n">linear_force_functions</span> <span class="o">=</span> <span class="n">standard_forces</span><span class="p">(</span><span class="n">hydro_data</span><span class="p">)</span>
        <span class="n">f_add</span> <span class="o">=</span> <span class="n">f_add</span> <span class="k">if</span> <span class="p">(</span><span class="n">f_add</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="p">{}</span>
        <span class="n">forces</span> <span class="o">=</span> <span class="n">linear_force_functions</span> <span class="o">|</span> <span class="n">f_add</span>
        <span class="c1"># constraints</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="n">constraints</span> <span class="k">if</span> <span class="p">(</span><span class="n">constraints</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="k">return</span> <span class="n">WEC</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">forces</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span> <span class="n">inertia_matrix</span><span class="p">,</span> <span class="n">dof_names</span><span class="o">=</span><span class="n">dof_names</span><span class="p">)</span></div>


<div class="viewcode-block" id="WEC.from_floating_body">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.from_floating_body.html#wecopttool.WEC.from_floating_body">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_floating_body</span><span class="p">(</span>
        <span class="n">fb</span><span class="p">:</span> <span class="n">cpy</span><span class="o">.</span><span class="n">FloatingBody</span><span class="p">,</span>
        <span class="n">f1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">friction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">f_add</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TIForceDict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_damping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">_default_min_damping</span><span class="p">,</span>
        <span class="n">wave_directions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,]),</span>
        <span class="n">rho</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">_default_parameters</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">],</span>
        <span class="n">g</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">_default_parameters</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">],</span>
        <span class="n">depth</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">_default_parameters</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TWEC</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a WEC object from a Capytaine :python:`FloatingBody`</span>
<span class="sd">        (:py:class:capytaine.bodies.bodies.FloatingBody).</span>

<span class="sd">        A :py:class:capytaine.bodies.bodies.FloatingBody object contains</span>
<span class="sd">        information on the mesh and degrees of freedom.</span>

<span class="sd">        This initialization method calls :py:func:`wecopttool.run_bem`</span>
<span class="sd">        followed by :py:meth:`wecopttool.WEC.from_bem`.</span>

<span class="sd">        This will run Capytaine to obtain the linear hydrodynamic</span>
<span class="sd">        coefficients, which can take from a few minutes to several</span>
<span class="sd">        hours.</span>
<span class="sd">        Instead, if the hydrodynamic coefficients can be reused, it is</span>
<span class="sd">        recommended to run Capytaine first and save the results using</span>
<span class="sd">        :py:func:`wecopttool.run_bem` and</span>
<span class="sd">        :py:func:`wecopttool.write_netcdf`,</span>
<span class="sd">        and then initialize the :py:class:`wecopttool.WEC` object</span>
<span class="sd">        using :py:meth:`wecopttool.WEC.from_bem`.</span>
<span class="sd">        This initialization method should be</span>
<span class="sd">        reserved for the cases where the hydrodynamic coefficients</span>
<span class="sd">        constantly change and are not reused, as for example for</span>
<span class="sd">        geometry optimization.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fb</span>
<span class="sd">            Capytaine FloatingBody.</span>
<span class="sd">        f1</span>
<span class="sd">            Fundamental frequency :python:`f1` [:math:`Hz`].</span>
<span class="sd">        nfreq</span>
<span class="sd">            Number of frequencies (not including zero frequency),</span>
<span class="sd">            i.e., :python:`freqs = [0, f1, 2*f1, ..., nfreq*f1]`.</span>
<span class="sd">        friction</span>
<span class="sd">            Linear friction, in addition to radiation damping, of size</span>
<span class="sd">            :python:`(ndof, ndof)`.</span>
<span class="sd">            :python:`None` to set to zero.</span>
<span class="sd">        f_add</span>
<span class="sd">            Dictionary with entries :python:`{&#39;force_name&#39;: fun}`, where</span>
<span class="sd">            :python:`fun` has a  signature</span>
<span class="sd">            :python:`def fun(wec, x_wec, x_opt, waves):`, and returns</span>
<span class="sd">            forces in the time-domain of size</span>
<span class="sd">            :python:`(2*nfreq, ndof)`.</span>
<span class="sd">        constraints</span>
<span class="sd">            List of constraints, see documentation for</span>
<span class="sd">            :py:func:`scipy.optimize.minimize` for description and</span>
<span class="sd">            options of constraints dictionaries.</span>
<span class="sd">            If :python:`None`: empty list :python:`[]`.</span>
<span class="sd">        min_damping</span>
<span class="sd">            Minimum damping level to ensure a stable system.</span>
<span class="sd">            See :py:func:`wecopttool.check_radiation_damping` for</span>
<span class="sd">            more details.</span>
<span class="sd">        wave_directions</span>
<span class="sd">            List of wave directions [degrees] to evaluate BEM at.</span>
<span class="sd">        rho</span>
<span class="sd">            Water density in :math:`kg/m^3`.</span>
<span class="sd">        g</span>
<span class="sd">            Gravitational acceleration in :math:`m/s^2`.</span>
<span class="sd">        depth</span>
<span class="sd">            Water depth in :math:`m`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        WEC</span>
<span class="sd">            An instance of the :py:class:`wecopttool.WEC` class.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        run_bem, write_netcdf, WEC.from_bem</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># RUN BEM</span>
        <span class="n">_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Running Capytaine (BEM): </span><span class="si">{</span><span class="n">nfreq</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> frequencies x &quot;</span> <span class="o">+</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">wave_directions</span><span class="p">)</span><span class="si">}</span><span class="s2"> wave directions.&quot;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">frequency</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="n">bem_data</span> <span class="o">=</span> <span class="n">run_bem</span><span class="p">(</span>
            <span class="n">fb</span><span class="p">,</span> <span class="n">freq</span><span class="p">,</span> <span class="n">wave_directions</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="n">depth</span><span class="p">)</span>
        <span class="n">wec</span> <span class="o">=</span> <span class="n">WEC</span><span class="o">.</span><span class="n">from_bem</span><span class="p">(</span>
            <span class="n">bem_data</span><span class="p">,</span> <span class="n">friction</span><span class="p">,</span> <span class="n">f_add</span><span class="p">,</span>
            <span class="n">constraints</span><span class="p">,</span> <span class="n">min_damping</span><span class="o">=</span><span class="n">min_damping</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wec</span></div>


<div class="viewcode-block" id="WEC.from_impedance">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.from_impedance.html#wecopttool.WEC.from_impedance">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_impedance</span><span class="p">(</span>
        <span class="n">freqs</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">impedance</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span>
        <span class="n">exc_coeff</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span>
        <span class="n">hydrostatic_stiffness</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
        <span class="n">f_add</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TIForceDict</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Iterable</span><span class="p">[</span><span class="n">Mapping</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">min_damping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">_default_min_damping</span><span class="p">,</span>
        <span class="n">uniform_shift</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TWEC</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a WEC object from the intrinsic impedance and</span>
<span class="sd">        excitation coefficients.</span>

<span class="sd">        The intrinsic (mechanical) impedance :math:`Z(ω)` linearly</span>
<span class="sd">        relates excitation forces :math:`F(ω)` to WEC velocity</span>
<span class="sd">        :math:`U(ω)` as :math:`ZU=F`.</span>
<span class="sd">        Using linear hydrodynamic coefficients, e.g. from a BEM code</span>
<span class="sd">        like Capytaine, the impedance is given as</span>
<span class="sd">        :math:`Z(ω) = (m+A(ω))*iω + B(ω) + B_f + K/(iω)`.</span>
<span class="sd">        The impedance can also be obtained experimentally.</span>
<span class="sd">        Note that the impedance is not defined at :math:`ω=0`.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        freqs</span>
<span class="sd">            Frequency vector [:math:`Hz`] not including the zero frequency,</span>
<span class="sd">            :python:`freqs = [f1, 2*f1, ..., nfreq*f1]`.</span>
<span class="sd">        impedance</span>
<span class="sd">            Complex impedance of size :python:`(nfreq, ndof, ndof)`.</span>
<span class="sd">        exc_coeff</span>
<span class="sd">            Complex excitation transfer function of size</span>
<span class="sd">            :python:`(ndof, nfreq)`.</span>
<span class="sd">        hydrostatic_stiffness</span>
<span class="sd">            Linear hydrostatic restoring coefficient of size</span>
<span class="sd">            :python:`(ndof, ndof)`.</span>
<span class="sd">        f_add</span>
<span class="sd">            Dictionary with entries :python:`{&#39;force_name&#39;: fun}`, where</span>
<span class="sd">            :python:`fun` has a  signature</span>
<span class="sd">            :python:`def fun(wec, x_wec, x_opt, waves):`, and returns</span>
<span class="sd">            forces in the time-domain of size</span>
<span class="sd">            :python:`(2*nfreq, ndof)`.</span>
<span class="sd">        constraints</span>
<span class="sd">            List of constraints, see documentation for</span>
<span class="sd">            :py:func:`scipy.optimize.minimize` for description and</span>
<span class="sd">            options of constraints dictionaries.</span>
<span class="sd">            If :python:`None`: empty list :python:`[]`.</span>
<span class="sd">        min_damping</span>
<span class="sd">            Minimum damping level to ensure a stable system.</span>
<span class="sd">            See :py:func:`wecopttool.check_impedance` for</span>
<span class="sd">            more details.</span>
<span class="sd">        uniform_shift</span>
<span class="sd">            Boolean determining whether damping corrections shifts the damping</span>
<span class="sd">            values uniformly for all frequencies or only for frequencies below</span>
<span class="sd">            :python:`min_damping`.</span>
<span class="sd">            See :py:func:`wecopttool.check_radiation_damping` for more details.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If :python:`impedance` does not have the correct size:</span>
<span class="sd">            :python:`(ndof, ndof, nfreq)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span> <span class="o">=</span> <span class="n">frequency_parameters</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># impedance matrix shape</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">impedance</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">impedance</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ndim</span><span class="o">!=</span><span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">!=</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="n">nfreq</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;&#39;impedance&#39; must have shape &#39;(nfreq, ndof, ndof)&#39;.&quot;</span><span class="p">)</span>

        <span class="n">impedance</span> <span class="o">=</span> <span class="n">check_impedance</span><span class="p">(</span><span class="n">impedance</span><span class="p">,</span> <span class="n">min_damping</span><span class="p">)</span>

        <span class="c1"># impedance force</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="n">freqs</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">omega0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">omega</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">transfer_func</span> <span class="o">=</span> <span class="n">impedance</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega0</span><span class="p">)</span>
        <span class="n">transfer_func0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">hydrostatic_stiffness</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">transfer_func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">transfer_func0</span><span class="p">,</span> <span class="n">transfer_func</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">transfer_func</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">transfer_func</span>  <span class="c1"># RHS of equation: ma = Σf</span>
        <span class="n">force_impedance</span> <span class="o">=</span> <span class="n">force_from_rao_transfer_function</span><span class="p">(</span><span class="n">transfer_func</span><span class="p">)</span>

        <span class="c1"># excitation force</span>
        <span class="n">force_excitation</span> <span class="o">=</span> <span class="n">force_from_waves</span><span class="p">(</span><span class="n">exc_coeff</span><span class="p">)</span>

        <span class="c1"># all forces</span>
        <span class="n">f_add</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="p">(</span><span class="n">f_add</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="k">else</span> <span class="n">f_add</span>
        <span class="n">forces</span> <span class="o">=</span>  <span class="p">{</span>
            <span class="s1">&#39;intrinsic_impedance&#39;</span><span class="p">:</span> <span class="n">force_impedance</span><span class="p">,</span>
            <span class="s1">&#39;excitation&#39;</span><span class="p">:</span> <span class="n">force_excitation</span>
        <span class="p">}</span>
        <span class="n">forces</span> <span class="o">=</span> <span class="n">forces</span> <span class="o">|</span> <span class="n">f_add</span>

        <span class="c1"># wec</span>
        <span class="n">wec</span> <span class="o">=</span> <span class="n">WEC</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">forces</span><span class="p">,</span> <span class="n">constraints</span><span class="p">,</span>
                  <span class="n">inertia_in_forces</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ndof</span><span class="o">=</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">wec</span></div>


<div class="viewcode-block" id="WEC.residual">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.residual.html#wecopttool.WEC.residual">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">residual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">waves</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the residual of the dynamic equation (r = m⋅a-Σf).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        x_wec</span>
<span class="sd">            WEC state vector.</span>
<span class="sd">        x_opt</span>
<span class="sd">            Optimization (control) state.</span>
<span class="sd">        waves</span>
<span class="sd">            :py:class:`xarray.Dataset` with the structure and elements</span>
<span class="sd">            shown by :py:mod:`wecopttool.waves`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">inertia_in_forces</span><span class="p">:</span>
            <span class="n">ri</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inertia</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">,</span> <span class="n">waves</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ri</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">ncomponents</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">])</span>
        <span class="c1"># forces, -Σf</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">ri</span> <span class="o">=</span> <span class="n">ri</span> <span class="o">-</span> <span class="n">f</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">,</span> <span class="n">waves</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dofmat_to_vec</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span></div>


    <span class="c1"># solve</span>
<div class="viewcode-block" id="WEC.solve">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.solve.html#wecopttool.WEC.solve">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">waves</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
        <span class="n">obj_fun</span><span class="p">:</span> <span class="n">TStateFunction</span><span class="p">,</span>
        <span class="n">nstate_opt</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">x_wec_0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">x_opt_0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ndarray</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_x_wec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">list</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">scale_x_opt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">FloatOrArray</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">scale_obj</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">optim_options</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="p">{},</span>
        <span class="n">use_grad</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">maximize</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">bounds_wec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Bounds</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">bounds_opt</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Bounds</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">callback</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">TStateFunction</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">OptimizeResult</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simulate WEC dynamics using a pseudo-spectral solution</span>
<span class="sd">        method and returns the raw results dictionary produced by</span>
<span class="sd">        :py:func:`scipy.optimize.minimize`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        waves</span>
<span class="sd">            :py:class:`xarray.Dataset` with the structure and elements</span>
<span class="sd">            shown by :py:mod:`wecopttool.waves`.</span>
<span class="sd">        obj_fun</span>
<span class="sd">            Objective function to minimize for pseudo-spectral solution,</span>
<span class="sd">            must have signature :python:`fun(wec, x_wec, x_opt, waves)`</span>
<span class="sd">            and return a scalar.</span>
<span class="sd">        nstate_opt</span>
<span class="sd">            Length of the optimization (controls) state vector.</span>
<span class="sd">        x_wec_0</span>
<span class="sd">            Initial guess for the WEC dynamics state.</span>
<span class="sd">            If :python:`None` it is randomly initiated.</span>
<span class="sd">        x_opt_0</span>
<span class="sd">            Initial guess for the optimization (control) state.</span>
<span class="sd">            If :python:`None` it is randomly initiated.</span>
<span class="sd">        scale_x_wec</span>
<span class="sd">            Factor(s) to scale each DOF in :python:`x_wec` by, to</span>
<span class="sd">            improve convergence.</span>
<span class="sd">            A single float or an array of size :python:`ndof`.</span>
<span class="sd">        scale_x_opt</span>
<span class="sd">            Factor(s) to scale :python:`x_opt` by, to improve</span>
<span class="sd">            convergence.</span>
<span class="sd">            A single float or an array of size :python:`nstate_opt`.</span>
<span class="sd">        scale_obj</span>
<span class="sd">            Factor to scale :python:`obj_fun` by, to improve</span>
<span class="sd">            convergence.</span>
<span class="sd">        optim_options</span>
<span class="sd">            Optimization options passed to the optimizer.</span>
<span class="sd">            See :py:func:`scipy.optimize.minimize`.</span>
<span class="sd">        use_grad</span>
<span class="sd">             If :python:`True`, optimization will utilize</span>
<span class="sd">             `autograd &lt;https://github.com/HIPS/autograd&gt;`_</span>
<span class="sd">             for gradients.</span>
<span class="sd">        maximize</span>
<span class="sd">            Whether to maximize the objective function.</span>
<span class="sd">            The default is to minimize the objective function.</span>
<span class="sd">        bounds_wec</span>
<span class="sd">            Bounds on the WEC components of the decision variable.</span>
<span class="sd">            See :py:func:`scipy.optimize.minimize`.</span>
<span class="sd">        bounds_opt</span>
<span class="sd">            Bounds on the optimization (control) components of the</span>
<span class="sd">            decision variable.</span>
<span class="sd">            See :py:func:`scipy.optimize.minimize`.</span>
<span class="sd">        callback</span>
<span class="sd">            Function called after each iteration, must have signature</span>
<span class="sd">            :python:`fun(wec, x_wec, x_opt, waves)`. The default</span>
<span class="sd">            provides status reports at each iteration via logging at the</span>
<span class="sd">            INFO level.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If :python:`scale_x_opt` is a scalar and</span>
<span class="sd">            :python:`nstate_opt` is not provided.</span>
<span class="sd">        Exception</span>
<span class="sd">            If the optimizer fails for any reason other than maximum</span>
<span class="sd">            number of states, i.e. for exit modes other than 0 or 9.</span>
<span class="sd">            See :py:mod:`scipy.optimize` for exit mode details.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The :py:meth:`wecopttool.WEC.solve` method only returns the</span>
<span class="sd">        raw results dictionary produced by :py:func:`scipy.optimize.minimize`.</span>

<span class="sd">        &gt;&gt;&gt; res_opt = wec.solve(waves=wave,</span>
<span class="sd">                                obj_fun=pto.average_power,</span>
<span class="sd">                                nstate_opt=2*nfreq+1)</span>

<span class="sd">        To get the post-processed results for the :py:class:`wecopttool.WEC`</span>
<span class="sd">        and :py:class:`wecopttool.pto.PTO` for a single realization, you</span>
<span class="sd">        may call</span>

<span class="sd">        &gt;&gt;&gt; realization = 0 # realization index</span>
<span class="sd">        &gt;&gt;&gt; res_wec_fd, res_wec_td = wec.post_process(wec,res_opt,wave,nsubsteps)</span>
<span class="sd">        &gt;&gt;&gt; res_pto_fd, res_pto_td = pto.post_process(wec,res_opt,wave,nsubsteps)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        wecopttool.waves,</span>
<span class="sd">        wecopttool.core.wec.post_process,</span>
<span class="sd">        wecopttool.core.pto.post_process,</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># x_wec scaling vector</span>
        <span class="k">if</span> <span class="n">scale_x_wec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">scale_x_wec</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_x_wec</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_x_wec</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">scale_x_wec</span> <span class="o">=</span> <span class="p">[</span><span class="n">scale_x_wec</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span>
        <span class="n">scale_x_wec</span> <span class="o">=</span> <span class="n">scale_dofs</span><span class="p">(</span><span class="n">scale_x_wec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomponents</span><span class="p">)</span>

        <span class="c1"># x_opt scaling vector</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_x_opt</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale_x_opt</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">nstate_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If &#39;scale_x_opt&#39; is a scalar, &quot;</span> <span class="o">+</span>
                                    <span class="s2">&quot;&#39;nstate_opt&#39; must be provided&quot;</span><span class="p">)</span>
            <span class="n">scale_x_opt</span> <span class="o">=</span> <span class="n">scale_dofs</span><span class="p">([</span><span class="n">scale_x_opt</span><span class="p">],</span> <span class="n">nstate_opt</span><span class="p">)</span>

        <span class="c1"># composite scaling vector</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">scale_x_wec</span><span class="p">,</span> <span class="n">scale_x_opt</span><span class="p">])</span>

        <span class="c1"># decision variable initial guess</span>
        <span class="k">if</span> <span class="n">x_wec_0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_wec_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstate_wec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">x_opt_0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x_opt_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="n">nstate_opt</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">x_wec_0</span><span class="p">,</span> <span class="n">x_opt_0</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span>

        <span class="c1"># bounds</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bounds_wec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">bounds_opt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bounds_in</span> <span class="o">=</span> <span class="p">[</span><span class="n">bounds_wec</span><span class="p">,</span> <span class="n">bounds_opt</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">bii</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bounds_in</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bii</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="n">bounds_in</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">Bounds</span><span class="p">(</span><span class="n">lb</span><span class="o">=</span><span class="p">[</span><span class="n">xibs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">xibs</span> <span class="ow">in</span> <span class="n">bii</span><span class="p">],</span>
                                            <span class="n">ub</span><span class="o">=</span><span class="p">[</span><span class="n">xibs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">xibs</span> <span class="ow">in</span> <span class="n">bii</span><span class="p">])</span>
            <span class="n">inf_wec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nstate_wec</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">inf_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nstate_opt</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">bounds_dflt</span> <span class="o">=</span> <span class="p">[</span><span class="n">Bounds</span><span class="p">(</span><span class="n">lb</span><span class="o">=-</span><span class="n">inf_wec</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="n">inf_wec</span><span class="p">),</span>
                            <span class="n">Bounds</span><span class="p">(</span><span class="n">lb</span><span class="o">=-</span><span class="n">inf_opt</span><span class="p">,</span> <span class="n">ub</span><span class="o">=</span><span class="n">inf_opt</span><span class="p">)]</span>
            <span class="n">bounds_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bi</span><span class="p">,</span> <span class="n">bd</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">bounds_in</span><span class="p">,</span> <span class="n">bounds_dflt</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">bi</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">bo</span> <span class="o">=</span> <span class="n">bi</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">bo</span> <span class="o">=</span> <span class="n">bd</span>
                <span class="n">bounds_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bo</span><span class="p">)</span>
            <span class="n">bounds</span> <span class="o">=</span> <span class="n">Bounds</span><span class="p">(</span><span class="n">lb</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">le</span><span class="o">.</span><span class="n">lb</span> <span class="k">for</span> <span class="n">le</span> <span class="ow">in</span> <span class="n">bounds_list</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">,</span>
                            <span class="n">ub</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">([</span><span class="n">le</span><span class="o">.</span><span class="n">ub</span> <span class="k">for</span> <span class="n">le</span> <span class="ow">in</span> <span class="n">bounds_list</span><span class="p">])</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">realization</span><span class="p">,</span> <span class="n">wave</span> <span class="ow">in</span> <span class="n">waves</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;realization&#39;</span><span class="p">):</span>

            <span class="n">_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Solving pseudo-spectral control problem &quot;</span>
                      <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;for realization number </span><span class="si">{</span><span class="n">realization</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="n">wave</span> <span class="o">=</span> <span class="n">wave</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">dim</span><span class="o">=</span><span class="s1">&#39;realization&#39;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
                      
            <span class="c1"># objective function</span>
            <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">maximize</span> <span class="k">else</span> <span class="mf">1.0</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">obj_fun_scaled</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_state</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">obj_fun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">,</span> <span class="n">wave</span><span class="p">)</span><span class="o">*</span><span class="n">scale_obj</span><span class="o">*</span><span class="n">sign</span>

            <span class="c1"># constraints</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">icons</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">):</span>
                <span class="n">icons_new</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="n">icons</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]}</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">make_new_fun</span><span class="p">(</span><span class="n">icons</span><span class="p">):</span>
                    <span class="k">def</span><span class="w"> </span><span class="nf">new_fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                        <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_state</span><span class="p">(</span><span class="n">x</span><span class="o">/</span><span class="n">scale</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">icons</span><span class="p">[</span><span class="s2">&quot;fun&quot;</span><span class="p">](</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">,</span> <span class="n">wave</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">new_fun</span>

                <span class="n">icons_new</span><span class="p">[</span><span class="s2">&quot;fun&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">make_new_fun</span><span class="p">(</span><span class="n">icons</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">use_grad</span><span class="p">:</span>
                    <span class="n">icons_new</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">(</span><span class="n">icons_new</span><span class="p">[</span><span class="s1">&#39;fun&#39;</span><span class="p">])</span>
                <span class="n">constraints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">icons_new</span>

            <span class="c1"># system dynamics through equality constraint, ma - Σf = 0</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">scaled_resid_fun</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">x_s</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">scale</span>
                <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_state</span><span class="p">(</span><span class="n">x_s</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">residual</span><span class="p">(</span><span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">,</span> <span class="n">wave</span><span class="p">)</span>

            <span class="n">eq_cons</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="s1">&#39;eq&#39;</span><span class="p">,</span> <span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">scaled_resid_fun</span><span class="p">}</span>
            <span class="k">if</span> <span class="n">use_grad</span><span class="p">:</span>
                <span class="n">eq_cons</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">jacobian</span><span class="p">(</span><span class="n">scaled_resid_fun</span><span class="p">)</span>
            <span class="n">constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eq_cons</span><span class="p">)</span>

            <span class="c1"># callback</span>
            <span class="k">if</span> <span class="n">callback</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">callback_scipy</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_state</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="n">max_x_opt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">x_opt</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_opt</span><span class="p">))</span>
                    <span class="n">_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Scaled [max(x_wec), max(x_opt), obj_fun(x)]: &quot;</span>
                              <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;[</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">x_wec</span><span class="p">))</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">, &quot;</span>
                              <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">max_x_opt</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">, &quot;</span>
                              <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj_fun_scaled</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">:</span><span class="s2">.2e</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">callback_scipy</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="n">x_s</span> <span class="o">=</span> <span class="n">x</span><span class="o">/</span><span class="n">scale</span>
                    <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_state</span><span class="p">(</span><span class="n">x_s</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">,</span> <span class="n">wave</span><span class="p">)</span>

            <span class="c1"># optimization problem</span>
            <span class="n">optim_options</span><span class="p">[</span><span class="s1">&#39;disp&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">optim_options</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;disp&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">problem</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;fun&#39;</span><span class="p">:</span> <span class="n">obj_fun_scaled</span><span class="p">,</span>
                        <span class="s1">&#39;x0&#39;</span><span class="p">:</span> <span class="n">x0</span><span class="p">,</span>
                        <span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="s1">&#39;SLSQP&#39;</span><span class="p">,</span>
                        <span class="s1">&#39;constraints&#39;</span><span class="p">:</span> <span class="n">constraints</span><span class="p">,</span>
                        <span class="s1">&#39;options&#39;</span><span class="p">:</span> <span class="n">optim_options</span><span class="p">,</span>
                        <span class="s1">&#39;bounds&#39;</span><span class="p">:</span> <span class="n">bounds</span><span class="p">,</span>
                        <span class="s1">&#39;callback&#39;</span><span class="p">:</span> <span class="n">callback_scipy</span><span class="p">,</span>
                        <span class="p">}</span>
            <span class="k">if</span> <span class="n">use_grad</span><span class="p">:</span>
                <span class="n">problem</span><span class="p">[</span><span class="s1">&#39;jac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">grad</span><span class="p">(</span><span class="n">obj_fun_scaled</span><span class="p">)</span>

            <span class="c1"># minimize</span>
            <span class="n">optim_res</span> <span class="o">=</span> <span class="n">minimize</span><span class="p">(</span><span class="o">**</span><span class="n">problem</span><span class="p">)</span>

            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">optim_res</span><span class="o">.</span><span class="n">message</span><span class="si">}</span><span class="s1">    (Exit mode </span><span class="si">{</span><span class="n">optim_res</span><span class="o">.</span><span class="n">status</span><span class="si">}</span><span class="s1">)&#39;</span>
            <span class="k">if</span> <span class="n">optim_res</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">optim_res</span><span class="o">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

            <span class="c1"># unscale</span>
            <span class="n">optim_res</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">optim_res</span><span class="o">.</span><span class="n">x</span> <span class="o">/</span> <span class="n">scale</span>
            <span class="n">optim_res</span><span class="o">.</span><span class="n">fun</span> <span class="o">=</span> <span class="n">optim_res</span><span class="o">.</span><span class="n">fun</span> <span class="o">/</span> <span class="n">scale_obj</span>
            <span class="n">optim_res</span><span class="o">.</span><span class="n">jac</span> <span class="o">=</span> <span class="n">optim_res</span><span class="o">.</span><span class="n">jac</span> <span class="o">/</span> <span class="n">scale_obj</span> <span class="o">*</span> <span class="n">scale</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">optim_res</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">results</span></div>


<div class="viewcode-block" id="WEC.post_process">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.post_process.html#wecopttool.WEC.post_process">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">post_process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">wec</span><span class="p">:</span> <span class="n">TWEC</span><span class="p">,</span>
        <span class="n">res</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">OptimizeResult</span><span class="p">,</span> <span class="n">Iterable</span><span class="p">],</span>
        <span class="n">waves</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
        <span class="n">nsubsteps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Dataset</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">Dataset</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Post-process the results from :py:meth:`wecopttool.WEC.solve`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        wec</span>
<span class="sd">            :py:class:`wecopttool.WEC` object.</span>
<span class="sd">        res</span>
<span class="sd">            Results produced by :py:meth:`wecopttool.WEC.solve`.</span>
<span class="sd">        waves</span>
<span class="sd">            :py:class:`xarray.Dataset` with the structure and elements</span>
<span class="sd">            shown by :py:mod:`wecopttool.waves`.</span>
<span class="sd">        nsubsteps</span>
<span class="sd">            Number of steps between the default (implied) time steps.</span>
<span class="sd">            A value of :python:`1` corresponds to the default step</span>
<span class="sd">            length.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        results_fd</span>
<span class="sd">            Dynamic responses in the frequency-domain.</span>
<span class="sd">        results_td</span>
<span class="sd">            Dynamic responses in the time-domain.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        The :py:meth:`wecopttool.WEC.solve` method only returns the</span>
<span class="sd">        raw results dictionary produced by :py:func:`scipy.optimize.minimize`.</span>

<span class="sd">        &gt;&gt;&gt; res_opt = wec.solve(waves=wave,</span>
<span class="sd">                                obj_fun=pto.average_power,</span>
<span class="sd">                                nstate_opt=2*nfreq+1)</span>

<span class="sd">        To get the post-processed results we may call</span>

<span class="sd">        &gt;&gt;&gt; res_wec_fd, res_wec_td = wec.post_process(wec, res_opt,wave)</span>

<span class="sd">        Note that :py:meth:`wecopttool.WEC.solve` method produces a list of</span>
<span class="sd">        results objects (one for each phase realization).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">wec</span> <span class="p">,</span> <span class="p">(</span><span class="s2">&quot;The same wec object should be used to call &quot;</span> <span class="o">+</span>
                                <span class="s2">&quot;post-process and be passed as an input.&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_postproc</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">waves</span><span class="p">,</span> <span class="n">nsubsteps</span><span class="p">):</span>
            <span class="n">create_time</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">datetime</span><span class="o">.</span><span class="n">utcnow</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">omega_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">waves</span><span class="o">.</span><span class="n">omega</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
            <span class="n">freq_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mi">0</span><span class="p">],</span> <span class="n">waves</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
            <span class="n">period_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="n">waves</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">values</span><span class="p">])</span>
            <span class="n">pos_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Position&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;m or rad&#39;</span><span class="p">}</span>
            <span class="n">vel_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Velocity&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;m/s or rad/s&#39;</span><span class="p">}</span>
            <span class="n">acc_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Acceleration&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;m/s^2 or rad/s^2&#39;</span><span class="p">}</span>
            <span class="n">omega_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Radial frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;rad/s&#39;</span><span class="p">}</span>
            <span class="n">freq_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;Hz&#39;</span><span class="p">}</span>
            <span class="n">period_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Period&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;s&#39;</span><span class="p">}</span>
            <span class="n">time_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Time&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;s&#39;</span><span class="p">}</span>
            <span class="n">dof_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Degree of freedom&#39;</span><span class="p">}</span>
            <span class="n">force_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Force or moment&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;N or Nm&#39;</span><span class="p">}</span>
            <span class="n">wave_elev_attr</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;long_name&#39;</span><span class="p">:</span> <span class="s1">&#39;Wave elevation&#39;</span><span class="p">,</span> <span class="s1">&#39;units&#39;</span><span class="p">:</span> <span class="s1">&#39;m&#39;</span><span class="p">}</span>
            <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">decompose_state</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>
            <span class="n">omega_coord</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;omega&quot;</span><span class="p">,</span> <span class="n">omega_vals</span><span class="p">,</span> <span class="n">omega_attr</span><span class="p">)</span>
            <span class="n">freq_coord</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;omega&quot;</span><span class="p">,</span> <span class="n">freq_vals</span><span class="p">,</span> <span class="n">freq_attr</span><span class="p">)</span>
            <span class="n">period_coord</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;omega&quot;</span><span class="p">,</span> <span class="n">period_vals</span><span class="p">,</span> <span class="n">period_attr</span><span class="p">)</span>
            <span class="n">dof_coord</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;influenced_dof&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dof_names</span><span class="p">,</span> <span class="n">dof_attr</span><span class="p">)</span>

            <span class="c1"># frequency domain</span>
            <span class="n">force_da_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">force</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">forces</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">force_td_tmp</span> <span class="o">=</span> <span class="n">force</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">,</span> <span class="n">waves</span><span class="p">)</span>
                <span class="n">force_fd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">td_to_fd</span><span class="p">(</span><span class="n">force_td_tmp</span><span class="p">)</span>
                <span class="n">force_da</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">force_fd</span><span class="p">,</span>
                                    <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;omega&quot;</span><span class="p">,</span> <span class="s2">&quot;influenced_dof&quot;</span><span class="p">],</span>
                                    <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                                        <span class="s1">&#39;omega&#39;</span><span class="p">:</span> <span class="n">omega_coord</span><span class="p">,</span>
                                        <span class="s1">&#39;freq&#39;</span><span class="p">:</span> <span class="n">freq_coord</span><span class="p">,</span>
                                        <span class="s1">&#39;period&#39;</span><span class="p">:</span> <span class="n">period_coord</span><span class="p">,</span>
                                        <span class="s1">&#39;influenced_dof&#39;</span><span class="p">:</span> <span class="n">dof_coord</span><span class="p">},</span>
                                    <span class="n">attrs</span><span class="o">=</span><span class="n">force_attr</span>
                                    <span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s1">&#39;type&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">name</span><span class="p">]})</span>
                <span class="n">force_da_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">force_da</span><span class="p">)</span>

            <span class="n">fd_forces</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">force_da_list</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;type&#39;</span><span class="p">)</span>
            <span class="n">fd_forces</span><span class="o">.</span><span class="n">type</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Type&#39;</span>
            <span class="n">fd_forces</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;force&#39;</span>
            <span class="n">fd_forces</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;long_name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;Force&#39;</span>

            <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vec_to_dofmat</span><span class="p">(</span><span class="n">x_wec</span><span class="p">)</span>
            <span class="n">pos_fd</span> <span class="o">=</span> <span class="n">real_to_complex</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>

            <span class="n">vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative_mat</span> <span class="o">@</span> <span class="n">pos</span>
            <span class="n">vel_fd</span> <span class="o">=</span> <span class="n">real_to_complex</span><span class="p">(</span><span class="n">vel</span><span class="p">)</span>

            <span class="n">acc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">derivative2_mat</span> <span class="o">@</span> <span class="n">pos</span>
            <span class="n">acc_fd</span> <span class="o">=</span> <span class="n">real_to_complex</span><span class="p">(</span><span class="n">acc</span><span class="p">)</span>

            <span class="n">fd_state</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span>
                <span class="n">data_vars</span><span class="o">=</span><span class="p">{</span>
                    <span class="s1">&#39;pos&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="s1">&#39;influenced_dof&#39;</span><span class="p">],</span> <span class="n">pos_fd</span><span class="p">,</span> <span class="n">pos_attr</span><span class="p">),</span>
                    <span class="s1">&#39;vel&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="s1">&#39;influenced_dof&#39;</span><span class="p">],</span> <span class="n">vel_fd</span><span class="p">,</span> <span class="n">vel_attr</span><span class="p">),</span>
                    <span class="s1">&#39;acc&#39;</span><span class="p">:</span> <span class="p">([</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="s1">&#39;influenced_dof&#39;</span><span class="p">],</span> <span class="n">acc_fd</span><span class="p">,</span> <span class="n">acc_attr</span><span class="p">)},</span>
                <span class="n">coords</span><span class="o">=</span><span class="p">{</span>
                    <span class="s1">&#39;omega&#39;</span><span class="p">:</span> <span class="n">omega_coord</span><span class="p">,</span>
                    <span class="s1">&#39;freq&#39;</span><span class="p">:</span> <span class="n">freq_coord</span><span class="p">,</span>
                    <span class="s1">&#39;period&#39;</span><span class="p">:</span> <span class="n">period_coord</span><span class="p">,</span>
                    <span class="s1">&#39;influenced_dof&#39;</span><span class="p">:</span> <span class="n">dof_coord</span><span class="p">},</span>
                <span class="n">attrs</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;time_created_utc&quot;</span><span class="p">:</span> <span class="n">create_time</span><span class="p">}</span>
            <span class="p">)</span>

            <span class="n">results_fd</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">merge</span><span class="p">([</span><span class="n">fd_state</span><span class="p">,</span> <span class="n">fd_forces</span><span class="p">,</span> <span class="n">waves</span><span class="p">])</span>
            <span class="n">results_fd</span> <span class="o">=</span> <span class="n">results_fd</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="s1">&#39;influenced_dof&#39;</span><span class="p">,</span> <span class="s1">&#39;type&#39;</span><span class="p">,</span>
                                            <span class="s1">&#39;wave_direction&#39;</span><span class="p">)</span>
            <span class="n">results_fd</span> <span class="o">=</span> <span class="n">results_fd</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># time domain</span>
            <span class="n">t_dat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_nsubsteps</span><span class="p">(</span><span class="n">nsubsteps</span><span class="p">)</span>
            <span class="n">time</span> <span class="o">=</span> <span class="n">DataArray</span><span class="p">(</span>
                <span class="n">data</span><span class="o">=</span><span class="n">t_dat</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">dims</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span> <span class="n">coords</span><span class="o">=</span><span class="p">[</span><span class="n">t_dat</span><span class="p">])</span>
            <span class="n">results_td</span> <span class="o">=</span> <span class="n">results_fd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">time_results</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">time</span><span class="p">))</span>

            <span class="n">results_td</span><span class="p">[</span><span class="s1">&#39;pos&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">pos_attr</span>
            <span class="n">results_td</span><span class="p">[</span><span class="s1">&#39;vel&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">vel_attr</span>
            <span class="n">results_td</span><span class="p">[</span><span class="s1">&#39;acc&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">acc_attr</span>
            <span class="n">results_td</span><span class="p">[</span><span class="s1">&#39;wave_elev&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">wave_elev_attr</span>
            <span class="n">results_td</span><span class="p">[</span><span class="s1">&#39;force&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">force_attr</span>
            <span class="n">results_td</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">attrs</span> <span class="o">=</span> <span class="n">time_attr</span>
            <span class="n">results_td</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time_created_utc&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">create_time</span>
            <span class="k">return</span> <span class="n">results_fd</span><span class="p">,</span> <span class="n">results_td</span>

        <span class="n">results_fd</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">results_td</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">ires</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">res</span><span class="p">):</span>
            <span class="n">ifd</span><span class="p">,</span> <span class="n">itd</span> <span class="o">=</span> <span class="n">_postproc</span><span class="p">(</span><span class="n">ires</span><span class="p">,</span> <span class="n">waves</span><span class="o">.</span><span class="n">sel</span><span class="p">(</span><span class="n">realization</span><span class="o">=</span><span class="n">idx</span><span class="p">),</span> <span class="n">nsubsteps</span><span class="p">)</span>
            <span class="n">results_fd</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ifd</span><span class="p">)</span>
            <span class="n">results_td</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">itd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">results_fd</span><span class="p">,</span> <span class="n">results_td</span></div>


    <span class="c1"># properties</span>
    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TForceDict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Dictionary of forces.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_forces</span>

    <span class="nd">@forces</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">forces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_forces</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">dict</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span>

    <span class="nd">@constraints</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_constraints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inertia_in_forces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether inertial &quot;forces&quot; are included in the</span>
<span class="sd">        :python:`forces` dictionary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_in_forces</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inertia_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Inertia (mass) matrix.</span>
<span class="sd">        :python:`None` if  :python:`inertia_in_forces is True`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inertia_matrix</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">inertia</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TStateFunction</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function representing the inertial term :math:`ma` in the</span>
<span class="sd">        WEC&#39;s dynamics equation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_inertia</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dof_names</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Names of the different degrees of freedom.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dof_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ndof</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of degrees of freedom.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ndof</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Frequency vector [:math:`Hz`].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">f1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fundamental frequency :python:`f1` [:math:`Hz`].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nfreq</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of frequencies, not including the zero-frequency.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">omega</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Radial frequency vector [rad/s].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_freq</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">period</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Period vector [s].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="n">np</span><span class="o">.</span><span class="n">Infinity</span><span class="p">],</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">_freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]])</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">w1</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fundamental radial frequency [rad/s].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">omega</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Time vector [s], size &#39;(2*nfreq, ndof)&#39;, not containing the</span>
<span class="sd">        end time &#39;tf&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Matrix to create time-series from Fourier coefficients.</span>

<span class="sd">        For some array of Fourier coefficients :python:`x`</span>
<span class="sd">        (excluding the sine component of the highest frequency), size</span>
<span class="sd">        :python:`(2*nfreq, ndof)`, the time series is obtained via</span>
<span class="sd">        :python:`time_mat @ x`, also size</span>
<span class="sd">        :python:`(2*nfreq, ndof)`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time_mat</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Matrix to create Fourier coefficients of the derivative of</span>
<span class="sd">        some quantity.</span>

<span class="sd">        For some array of Fourier coefficients :python:`x`</span>
<span class="sd">        (excluding the sine component of the highest frequency), size</span>
<span class="sd">        :python:`(2*nfreq, ndof)`, the Fourier coefficients of the</span>
<span class="sd">        derivative of :python:`x` are obtained via</span>
<span class="sd">        :python:`derivative_mat @ x`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative_mat</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">derivative2_mat</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Matrix to create Fourier coefficients of the second derivative of</span>
<span class="sd">        some quantity.</span>

<span class="sd">        For some array of Fourier coefficients :python:`x`</span>
<span class="sd">        (excluding the sine component of the highest frequency), size</span>
<span class="sd">        :python:`(2*nfreq, ndof)`, the Fourier coefficients of the</span>
<span class="sd">        second derivative of :python:`x` are obtained via</span>
<span class="sd">        :python:`derivative2_mat @ x`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_derivative2_mat</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Time spacing [s].&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_time</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tf</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Final time (repeat period) [s]. Not included in</span>
<span class="sd">        :python:`time` vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">f1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nt</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of timesteps.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomponents</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ncomponents</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of Fourier components (:python:`2*nfreq`) for each</span>
<span class="sd">        degree of freedom. Note that the sine component of the highest</span>
<span class="sd">        frequency (the 2-point wave) is excluded as this will always</span>
<span class="sd">        evaluate to zero.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">ncomponents</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nstate_wec</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of the WEC dynamics state vector consisting of the</span>
<span class="sd">        Fourier coefficient of the position of each degree of freedom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">ncomponents</span>

    <span class="c1"># other methods</span>
<div class="viewcode-block" id="WEC.decompose_state">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.decompose_state.html#wecopttool.WEC.decompose_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">decompose_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
        <span class="n">state</span><span class="p">:</span> <span class="n">ndarray</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split the state vector into the WEC dynamics state and the</span>
<span class="sd">        optimization (control) state.</span>

<span class="sd">        Calls :py:func:`wecopttool.decompose_state` with the</span>
<span class="sd">        appropriate inputs for the WEC object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x_wec, x_opt = wec.decompose_state(x)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state</span>
<span class="sd">            Combined WEC and optimization states.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        state_wec</span>
<span class="sd">            WEC state vector.</span>
<span class="sd">        state_opt</span>
<span class="sd">            Optimization (control) state.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        decompose_state</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">decompose_state</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="p">)</span></div>


<div class="viewcode-block" id="WEC.time_nsubsteps">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.time_nsubsteps.html#wecopttool.WEC.time_nsubsteps">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_nsubsteps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsubsteps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a time vector with finer discretization.</span>

<span class="sd">        Calls :py:func:`wecopttool.time` with the appropriate</span>
<span class="sd">        inputs for the WEC object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsubsteps</span>
<span class="sd">            Number of substeps between implied/default time steps.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        time, WEC.time</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">time</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsubsteps</span><span class="p">)</span></div>


<div class="viewcode-block" id="WEC.time_mat_nsubsteps">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.time_mat_nsubsteps.html#wecopttool.WEC.time_mat_nsubsteps">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">time_mat_nsubsteps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nsubsteps</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a time matrix similar to</span>
<span class="sd">        :py:meth:`wecopttool.WEC.time_mat` but with finer</span>
<span class="sd">        time-domain discretization.</span>

<span class="sd">        Calls :py:func:`wecopttool.time_mat` with the appropriate</span>
<span class="sd">        inputs for the WEC object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        nsubsteps</span>
<span class="sd">            Number of substeps between implied/default time steps.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        time_mat, WEC.time_mat, WEC.time_nsubsteps</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">time_mat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">f1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">nsubsteps</span><span class="p">)</span></div>


<div class="viewcode-block" id="WEC.vec_to_dofmat">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.vec_to_dofmat.html#wecopttool.WEC.vec_to_dofmat">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vec_to_dofmat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a vector to a matrix with one column per degree of</span>
<span class="sd">        freedom.</span>

<span class="sd">        Opposite of :py:meth:`wecopttool.WEC.dofmat_to_vec`.</span>

<span class="sd">        Calls :py:func:`wecopttool.vec_to_dofmat` with the</span>
<span class="sd">        appropriate inputs for the WEC object.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; x_wec, x_opt = wec.decompose_state(x)</span>
<span class="sd">        &gt;&gt;&gt; x_wec_mat = wec.vec_to_dofmat(x_wec)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vec</span>
<span class="sd">            One-dimensional vector.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        vec_to_dofmat, WEC.dofmat_to_vec</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">vec_to_dofmat</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndof</span><span class="p">)</span></div>


<div class="viewcode-block" id="WEC.dofmat_to_vec">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.dofmat_to_vec.html#wecopttool.WEC.dofmat_to_vec">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dofmat_to_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mat</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Flatten a matrix to a vector.</span>

<span class="sd">        Opposite of :py:meth:`wecopttool.WEC.vec_to_dofmat`.</span>

<span class="sd">        Calls :py:func:`wecopttool.dofmat_to_vec` with the</span>
<span class="sd">        appropriate inputs for the WEC object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mat</span>
<span class="sd">            Matrix with one column per degree of freedom.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        dofmat_to_vec, WEC.vec_to_dofmat</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dofmat_to_vec</span><span class="p">(</span><span class="n">mat</span><span class="p">)</span></div>


<div class="viewcode-block" id="WEC.fd_to_td">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.fd_to_td.html#wecopttool.WEC.fd_to_td">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">fd_to_td</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fd</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a frequency-domain array to time-domain.</span>

<span class="sd">        Opposite of :py:meth:`wecopttool.WEC.td_to_fd`.</span>

<span class="sd">        Calls :py:func:`wecopttool.fd_to_td` with the appropriate inputs</span>
<span class="sd">        for the WEC object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fd</span>
<span class="sd">            Frequency-domain complex array with shape</span>
<span class="sd">            :python:`(WEC.nfreq+1, N)` for any :python:`N`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fd_to_td, WEC.td_to_fd</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">fd_to_td</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">f1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nfreq</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="WEC.td_to_fd">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.WEC.td_to_fd.html#wecopttool.WEC.td_to_fd">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">td_to_fd</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">td</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
        <span class="n">fft</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a time-domain array to frequency-domain.</span>

<span class="sd">        Opposite of :py:meth:`wecopttool.WEC.fd_to_td`.</span>

<span class="sd">        Calls :py:func:`wecopttool.fd_to_td` with the appropriate</span>
<span class="sd">        inputs for the WEC object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        td</span>
<span class="sd">            Time-domain real array with shape</span>
<span class="sd">            :python:`(2*WEC.nfreq, N)` for any :python:`N`.</span>
<span class="sd">        fft</span>
<span class="sd">            Whether to use the real FFT.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        td_to_fd, WEC.fd_to_td</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">td_to_fd</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">fft</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div>
</div>



<div class="viewcode-block" id="ncomponents">
<a class="viewcode-back" href="../../api_docs/wecopttool.ncomponents.html#wecopttool.ncomponents">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">ncomponents</span><span class="p">(</span>
    <span class="n">nfreq</span> <span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Number of Fourier components (:python:`2*nfreq`) for each</span>
<span class="sd">    DOF. The sine component of the highest frequency (the 2-point wave)</span>
<span class="sd">    is excluded as it will always evaluate to zero.</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    :python:`X0` is excluded, and the number of components is reduced by 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether to include the zero-frequency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ncomp</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">nfreq</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="n">ncomp</span> <span class="o">=</span> <span class="n">ncomp</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">return</span> <span class="n">ncomp</span></div>



<div class="viewcode-block" id="frequency">
<a class="viewcode-back" href="../../api_docs/wecopttool.frequency.html#wecopttool.frequency">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">frequency</span><span class="p">(</span>
    <span class="n">f1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Construct equally spaced frequency array.</span>

<span class="sd">    The array includes :python:`0` and has length of :python:`nfreq+1`.</span>
<span class="sd">    :python:`f1` is fundamental frequency (1st harmonic).</span>

<span class="sd">    Returns the frequency array, e.g.,</span>
<span class="sd">    :python:`freqs = [0, f1, 2*f1, ..., nfreq*f1]`.</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    :python:`0` is excluded, and the vector length is reduced by 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f1</span>
<span class="sd">        Fundamental frequency :python:`f1` [:math:`Hz`].</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether to include the zero-frequency.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">nfreq</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">f1</span>
    <span class="n">freq</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">zero_freq</span> <span class="k">else</span> <span class="n">freq</span>
    <span class="k">return</span> <span class="n">freq</span></div>



<div class="viewcode-block" id="time">
<a class="viewcode-back" href="../../api_docs/wecopttool.time.html#wecopttool.time">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">time</span><span class="p">(</span>
    <span class="n">f1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nsubsteps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble the time vector with :python:`nsubsteps` subdivisions.</span>

<span class="sd">    Returns the 1D time vector, in seconds, starting at time</span>
<span class="sd">    :python:`0`, and not containing the end time :python:`tf=1/f1`.</span>
<span class="sd">    The time vector has length :python:`(2*nfreq)*nsubsteps`.</span>
<span class="sd">    The timestep length is :python:`dt = dt_default * 1/nsubsteps`,</span>
<span class="sd">    where :python:`dt_default=tf/(2*nfreq)`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f1</span>
<span class="sd">        Fundamental frequency :python:`f1` [:math:`Hz`].</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies.</span>
<span class="sd">    nsubsteps</span>
<span class="sd">        Number of steps between the default (implied) time steps.</span>
<span class="sd">        A value of :python:`1` corresponds to the default step length.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nsubsteps</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;&#39;nsubsteps&#39; must be 1 or greater&quot;</span><span class="p">)</span>
    <span class="n">nsteps</span> <span class="o">=</span> <span class="n">nsubsteps</span> <span class="o">*</span> <span class="n">ncomponents</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">f1</span><span class="p">,</span> <span class="n">nsteps</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="time_mat">
<a class="viewcode-back" href="../../api_docs/wecopttool.time_mat.html#wecopttool.time_mat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">time_mat</span><span class="p">(</span>
    <span class="n">f1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nsubsteps</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble the time matrix that converts the state to a</span>
<span class="sd">    time-series.</span>

<span class="sd">    For a state :math:`x` consisting of the mean (DC) component</span>
<span class="sd">    followed by the real and imaginary components of the Fourier</span>
<span class="sd">    coefficients (excluding the imaginary component of the 2-point wave) as</span>
<span class="sd">    :math:`x=[X0, Re(X1), Im(X1), ..., Re(Xn)]`,</span>
<span class="sd">    the response vector in the time-domain (:math:`x(t)`) is given as</span>
<span class="sd">    :math:`Mx`, where :math:`M` is the time matrix.</span>

<span class="sd">    The time matrix has size :python:`(nfreq*2, nfreq*2)`.</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    :python:`X0` is excluded, and the matrix/vector length is reduced by 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    f1</span>
<span class="sd">        Fundamental frequency :python:`f1` [:math:`Hz`].</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies.</span>
<span class="sd">    nsubsteps</span>
<span class="sd">        Number of steps between the default (implied) time steps.</span>
<span class="sd">        A value of :python:`1` corresponds to the default step length.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the first frequency should be zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">time</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">nsubsteps</span><span class="p">)</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">frequency</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">wt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">omega</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
    <span class="n">ncomp</span> <span class="o">=</span> <span class="n">ncomponents</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>
    <span class="n">time_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">((</span><span class="n">nsubsteps</span><span class="o">*</span><span class="n">ncomp</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">))</span>
    <span class="n">time_mat</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
    <span class="n">time_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">wt</span><span class="p">)</span>
    <span class="n">time_mat</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">wt</span><span class="p">[:,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># remove 2pt wave sine component</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="n">time_mat</span> <span class="o">=</span> <span class="n">time_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">time_mat</span></div>



<div class="viewcode-block" id="derivative_mat">
<a class="viewcode-back" href="../../api_docs/wecopttool.derivative_mat.html#wecopttool.derivative_mat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">derivative_mat</span><span class="p">(</span>
    <span class="n">f1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble the derivative matrix that converts the state vector of</span>
<span class="sd">    a response to the state vector of its derivative.</span>

<span class="sd">    For a state :math:`x` consisting of the mean (DC) component</span>
<span class="sd">    followed by the real and imaginary components of the Fourier</span>
<span class="sd">    coefficients (excluding the imaginary component of the 2-point wave) as</span>
<span class="sd">    :math:`x=[X0, Re(X1), Im(X1), ..., Re(Xn)]`,</span>
<span class="sd">    the state of its derivative is given as :math:`Dx`, where</span>
<span class="sd">    :math:`D` is the derivative matrix.</span>

<span class="sd">    The time matrix has size :python:`(nfreq*2, nfreq*2)`.</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    :python:`X0` is excluded, and the matrix/vector length is reduced by 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    f1</span>
<span class="sd">        Fundamental frequency :python:`f1` [:math:`Hz`].</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the first frequency should be zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">block</span><span class="p">(</span><span class="n">n</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span> <span class="o">*</span> <span class="n">n</span><span class="o">*</span><span class="n">f1</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">block</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)]</span>
    <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span> <span class="o">+</span> <span class="n">blocks</span>
    <span class="n">deriv_mat</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">deriv_mat</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># remove 2pt wave sine component</span></div>



<div class="viewcode-block" id="derivative2_mat">
<a class="viewcode-back" href="../../api_docs/wecopttool.derivative2_mat.html#wecopttool.derivative2_mat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">derivative2_mat</span><span class="p">(</span>
    <span class="n">f1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Assemble the second derivative matrix that converts the state vector of</span>
<span class="sd">    a response to the state vector of its second derivative.</span>

<span class="sd">    For a state :math:`x` consisting of the mean (DC) component</span>
<span class="sd">    followed by the real and imaginary components of the Fourier</span>
<span class="sd">    coefficients (excluding the imaginary component of the 2-point wave) as</span>
<span class="sd">    :math:`x=[X0, Re(X1), Im(X1), ..., Re(Xn)]`,</span>
<span class="sd">    the state of its second derivative is given as :math:`(DD)x`, where</span>
<span class="sd">    :math:`DD` is the second derivative matrix.</span>

<span class="sd">    The time matrix has size :python:`(nfreq*2, nfreq*2)`.</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    :python:`X0` is excluded, and the matrix/vector length is reduced by 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ---------</span>
<span class="sd">    f1</span>
<span class="sd">        Fundamental frequency :python:`f1` [:math:`Hz`].</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the first frequency should be zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">vals</span> <span class="o">=</span> <span class="p">[((</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">f1</span> <span class="o">*</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)]</span>
    <span class="n">diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span> <span class="o">*</span> <span class="n">vals</span><span class="p">,</span> <span class="mi">2</span><span class="p">)[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="c1"># remove 2pt wave sine</span>
    <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="n">diagonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(([</span><span class="mf">0.0</span><span class="p">],</span> <span class="n">diagonal</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diagonal</span><span class="p">)</span></div>



<div class="viewcode-block" id="mimo_transfer_mat">
<a class="viewcode-back" href="../../api_docs/wecopttool.mimo_transfer_mat.html#wecopttool.mimo_transfer_mat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">mimo_transfer_mat</span><span class="p">(</span>
    <span class="n">transfer_mat</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a block matrix of the MIMO transfer function.</span>

<span class="sd">    The input is a complex transfer matrix that relates the complex</span>
<span class="sd">    Fourier representation of two variables.</span>
<span class="sd">    For example, it can be an impedance matrix or an RAO transfer</span>
<span class="sd">    matrix.</span>
<span class="sd">    The input complex impedance matrix has shape</span>
<span class="sd">    :python`(nfreq, ndof, ndof)`.</span>

<span class="sd">    Returns the 2D real matrix that transform the state representation</span>
<span class="sd">    of the input variable variable to the state representation of the</span>
<span class="sd">    output variable.</span>
<span class="sd">    Here, a state representation :python:`x` consists of the mean (DC)</span>
<span class="sd">    component followed by the real and imaginary components of the</span>
<span class="sd">    Fourier coefficients (excluding the imaginary component of the</span>
<span class="sd">    2-point wave) as</span>
<span class="sd">    :python:`x=[X0, Re(X1), Im(X1), ..., Re(Xn)]`.</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    :python:`X0` is excluded, and the matrix/vector length is reduced by 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    transfer_mat</span>
<span class="sd">        Complex transfer matrix.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the first frequency should be zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndof</span> <span class="o">=</span> <span class="n">transfer_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">assert</span> <span class="n">transfer_mat</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="n">ndof</span>
    <span class="n">elem</span> <span class="o">=</span> <span class="p">[[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">ndof</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndof</span><span class="p">)]</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">block</span><span class="p">(</span><span class="n">re</span><span class="p">,</span> <span class="n">im</span><span class="p">):</span> <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">re</span><span class="p">,</span> <span class="o">-</span><span class="n">im</span><span class="p">],</span> <span class="p">[</span><span class="n">im</span><span class="p">,</span> <span class="n">re</span><span class="p">]])</span>
    <span class="k">for</span> <span class="n">idof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndof</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">jdof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndof</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
                <span class="n">Zp0</span> <span class="o">=</span> <span class="n">transfer_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">idof</span><span class="p">,</span> <span class="n">jdof</span><span class="p">]</span>
                <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">Zp0</span><span class="p">))</span>
                <span class="n">Zp0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Zp0</span><span class="p">)</span>
                <span class="n">Zp</span> <span class="o">=</span> <span class="n">transfer_mat</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="n">idof</span><span class="p">,</span> <span class="n">jdof</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Zp0</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">]</span>
                <span class="n">Zp</span> <span class="o">=</span> <span class="n">transfer_mat</span><span class="p">[:,</span> <span class="n">idof</span><span class="p">,</span> <span class="n">jdof</span><span class="p">]</span>
            <span class="n">re</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Zp</span><span class="p">)</span>
            <span class="n">im</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">Zp</span><span class="p">)</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">block</span><span class="p">(</span><span class="n">ire</span><span class="p">,</span> <span class="n">iim</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">ire</span><span class="p">,</span> <span class="n">iim</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">re</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">im</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])]</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">Zp0</span><span class="p">]</span> <span class="o">+</span> <span class="n">blocks</span> <span class="o">+</span> <span class="p">[</span><span class="n">re</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">elem</span><span class="p">[</span><span class="n">idof</span><span class="p">][</span><span class="n">jdof</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_diag</span><span class="p">(</span><span class="o">*</span><span class="n">blocks</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span></div>



<div class="viewcode-block" id="vec_to_dofmat">
<a class="viewcode-back" href="../../api_docs/wecopttool.vec_to_dofmat.html#wecopttool.vec_to_dofmat">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">vec_to_dofmat</span><span class="p">(</span><span class="n">vec</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span> <span class="n">ndof</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a vector back to a matrix with one column per DOF.</span>

<span class="sd">    Returns a matrix with :python:`ndof` columns.</span>
<span class="sd">    The number of rows is inferred from the size of the input vector.</span>

<span class="sd">    Opposite of :py:func:`wecopttool.dofmat_to_vec`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    vec</span>
<span class="sd">        1D array consisting of concatenated arrays of several DOFs, as</span>
<span class="sd">        :python:`vec = [vec_1, vec_2, ..., vec_ndof]`.</span>
<span class="sd">    ndof</span>
<span class="sd">        Number of degrees of freedom.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    dofmat_to_vec,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">vec</span><span class="p">,</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ndof</span><span class="p">),</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="dofmat_to_vec">
<a class="viewcode-back" href="../../api_docs/wecopttool.dofmat_to_vec.html#wecopttool.dofmat_to_vec">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">dofmat_to_vec</span><span class="p">(</span><span class="n">mat</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Flatten a matrix that has one column per DOF.</span>

<span class="sd">    Returns a 1D vector.</span>

<span class="sd">    Opposite of :py:func:`wecopttool.vec_to_dofmat`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    mat</span>
<span class="sd">        Matrix to be flattened.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    vec_to_dofmat,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">mat</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="real_to_complex">
<a class="viewcode-back" href="../../api_docs/wecopttool.real_to_complex.html#wecopttool.real_to_complex">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">real_to_complex</span><span class="p">(</span>
    <span class="n">fd</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert from two real amplitudes to one complex amplitude per</span>
<span class="sd">    frequency.</span>

<span class="sd">    The input is a real 2D array with each column containing the real</span>
<span class="sd">    and imaginary components of the Fourier coefficients for some</span>
<span class="sd">    response, excluding the imaginary component of the highest frequency</span>
<span class="sd">    (2-point wave).</span>
<span class="sd">    The column length is :python:`2*nfreq`.</span>
<span class="sd">    The entries of a column representing a response :python:`x` are</span>
<span class="sd">    :python:`x=[X0, Re(X1), Im(X1), ..., Re(Xn)]`.</span>

<span class="sd">    Returns a complex 2D array with each column containing the complex</span>
<span class="sd">    Fourier coefficients.</span>
<span class="sd">    Columns are length :python:`nfreq+1`, and the first row corresponds</span>
<span class="sd">    to the real-valued zero-frequency (mean, DC) components.</span>
<span class="sd">    The entries of a column representing a response :python:`x` are</span>
<span class="sd">    :python:`x=[X0, X1, ..., Xn]`.</span>

<span class="sd">    If :python:`zero_freq = False`, the mean (DC) component :python:`X0`</span>
<span class="sd">    is excluded, and the column length is reduced by 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fd</span>
<span class="sd">        Array containing the real and imaginary components of the</span>
<span class="sd">        Fourier coefficients.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the mean (DC) component is included.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    complex_to_real,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fd</span><span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">0</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
    <span class="n">fdc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">:],</span>
                    <span class="p">[</span><span class="n">fd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="n">fdc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">mean</span><span class="p">,</span> <span class="n">fdc</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fdc</span></div>



<div class="viewcode-block" id="complex_to_real">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.complex_to_real.html#wecopttool.complex_to_real">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">complex_to_real</span><span class="p">(</span>
    <span class="n">fd</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert from one complex amplitude to two real amplitudes per</span>
<span class="sd">    frequency.</span>

<span class="sd">    The input is a complex 2D array with each column containing the</span>
<span class="sd">    Fourier coefficients for some response.</span>
<span class="sd">    Columns are length :python:`nfreq+1`, and the first row corresponds</span>
<span class="sd">    to the real-valued zero-frequency (mean, DC) components.</span>
<span class="sd">    The entries of a column representing a response :python:`x` are</span>
<span class="sd">    :python:`x=[X0, X1, ..., Xn]`.</span>

<span class="sd">    Returns a real 2D array with each column containing the real and</span>
<span class="sd">    imaginary components of the Fourier coefficients. The imaginary component</span>
<span class="sd">    of the highest frequency (the 2-point wave) is excluded, as it will</span>
<span class="sd">    always evaluate to zero.</span>
<span class="sd">    The column length is :python:`2*nfreq`.</span>
<span class="sd">    The entries of a column representing a response :python:`x` are</span>
<span class="sd">    :python:`x=[X0, Re(X1), Im(X1), ..., Re(Xn)]`.</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    :python:`X0` is excluded, and the vector length is reduced by 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fd</span>
<span class="sd">        Array containing the complex Fourier coefficients.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the mean (DC) component is included.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    real_to_complex,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>
    <span class="n">nfreq</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">zero_freq</span> <span class="k">else</span> <span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ndof</span> <span class="o">=</span> <span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isreal</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fd</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">fd</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:])</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">c</span><span class="p">)])</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">),</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ndof</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nfreq</span><span class="p">,</span> <span class="n">ndof</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">out</span><span class="p">,</span> <span class="n">d</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">out</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">nfreq</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">ndof</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="fd_to_td">
<a class="viewcode-back" href="../../api_docs/wecopttool.fd_to_td.html#wecopttool.fd_to_td">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">fd_to_td</span><span class="p">(</span>
    <span class="n">fd</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">f1</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">nfreq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a complex array of Fourier coefficients to a real array</span>
<span class="sd">    of time-domain responses.</span>

<span class="sd">    The input is a complex 2D array with each column containing the</span>
<span class="sd">    Fourier coefficients for some response.</span>
<span class="sd">    Columns are length :python:`nfreq+1`, and the first row corresponds</span>
<span class="sd">    to the real-valued zero-frequency (mean, DC) components.</span>
<span class="sd">    The entries of a column representing a response :python:`x` are</span>
<span class="sd">    :python:`x=[X0, X1, ..., Xn]`.</span>

<span class="sd">    Returns a real array with same number of columns and</span>
<span class="sd">    :python:`2*nfreq` rows, containing the time-domain response at</span>
<span class="sd">    times :python:`wecopttool.time(f1, nfreq, nsubsteps=1)`.</span>
<span class="sd">    The imaginary component of the highest frequency (the 2-point wave) is</span>
<span class="sd">    excluded, as it will always evaluate to zero.</span>

<span class="sd">    If both :python:`f1` and :python:`nfreq` are provided, it uses the</span>
<span class="sd">    time matrix :python:`wecopttool.time_mat(f1, nfreq, nsubsteps=1)`,</span>
<span class="sd">    else it uses the inverse real FFT (:py:func:`numpy.fft.irfft`).</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    :python:`X0` is excluded, and the matrix/vector length is reduced by 1.</span>

<span class="sd">    Opposite of :py:meth:`wecopttool.td_to_fd`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fd</span>
<span class="sd">        Array containing the complex Fourier coefficients.</span>
<span class="sd">    f1</span>
<span class="sd">        Fundamental frequency :python:`f1` [:math:`Hz`].</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the mean (DC) component is included.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If only one of :python:`f1` or :python:`nfreq` is provided.</span>
<span class="sd">        Must provide both or neither.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    td_to_fd, time, time_mat</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;The first row must be real when `zero_freq=True`.&quot;</span>
        <span class="k">assert</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">fd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]),</span> <span class="mi">0</span><span class="p">),</span> <span class="n">msg</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">f1</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nfreq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">tmat</span> <span class="o">=</span> <span class="n">time_mat</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="n">zero_freq</span><span class="o">=</span><span class="n">zero_freq</span><span class="p">)</span>
        <span class="n">td</span> <span class="o">=</span> <span class="n">tmat</span> <span class="o">@</span> <span class="n">complex_to_real</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">zero_freq</span><span class="p">)</span>
    <span class="k">elif</span> <span class="p">(</span><span class="n">f1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">nfreq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">fd</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="n">fd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]))</span>
        <span class="n">td</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Provide either both &#39;f1&#39; and &#39;nfreq&#39; or neither.&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">td</span></div>



<div class="viewcode-block" id="td_to_fd">
<a class="viewcode-back" href="../../api_docs/wecopttool.td_to_fd.html#wecopttool.td_to_fd">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">td_to_fd</span><span class="p">(</span>
    <span class="n">td</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">fft</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a real array of time-domain responses to a complex array</span>
<span class="sd">    of Fourier coefficients.</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    :python:`X0` is excluded, and the matrix/vector length is reduced by 1.</span>

<span class="sd">    Opposite of :py:func:`wecopttool.fd_to_td`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    td</span>
<span class="sd">        Real array of time-domains responses.</span>
<span class="sd">    fft</span>
<span class="sd">        Whether to use the real FFT.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the mean (DC) component is returned.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    fd_to_td</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">td</span><span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">td</span><span class="p">)</span>
    <span class="n">n</span> <span class="o">=</span> <span class="n">td</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fft</span><span class="p">:</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">td</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;forward&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">dft</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="s1">&#39;n&#39;</span><span class="p">)[:</span><span class="n">n</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">td</span><span class="p">)</span>
    <span class="n">fd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">fd</span><span class="p">[:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span> <span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">fd</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">zero_freq</span><span class="p">:</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="n">fd</span><span class="p">[</span><span class="mi">1</span><span class="p">:,</span> <span class="p">:]</span>
    <span class="k">return</span> <span class="n">fd</span></div>



<div class="viewcode-block" id="read_netcdf">
<a class="viewcode-back" href="../../api_docs/wecopttool.read_netcdf.html#wecopttool.read_netcdf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">read_netcdf</span><span class="p">(</span><span class="n">fpath</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Read a *NetCDF* file with possibly complex entries as a</span>
<span class="sd">    :py:class:`xarray.Dataset`.</span>

<span class="sd">    Can handle complex entries in the *NetCDF* by using</span>
<span class="sd">    :py:func:`capytaine.io.xarray.merge_complex_values`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fpath</span>
<span class="sd">        Path to the *NetCDF* file.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    write_netcdf,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="n">xr</span><span class="o">.</span><span class="n">open_dataset</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span> <span class="k">as</span> <span class="n">ds</span><span class="p">:</span>
        <span class="n">ds</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">cpy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">xarray</span><span class="o">.</span><span class="n">merge_complex_values</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span></div>



<div class="viewcode-block" id="write_netcdf">
<a class="viewcode-back" href="../../api_docs/wecopttool.write_netcdf.html#wecopttool.write_netcdf">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">write_netcdf</span><span class="p">(</span><span class="n">fpath</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">],</span> <span class="n">data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Save an :py:class:`xarray.Dataset` with possibly complex entries as a</span>
<span class="sd">    *NetCDF* file.</span>

<span class="sd">    Can handle complex entries in the *NetCDF* by using</span>
<span class="sd">    :py:func:`capytaine.io.xarray.separate_complex_values`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fpath</span>
<span class="sd">        Name of file to save.</span>
<span class="sd">    data</span>
<span class="sd">        Dataset to save.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    read_netcdf,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">cpy</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">xarray</span><span class="o">.</span><span class="n">separate_complex_values</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">.</span><span class="n">to_netcdf</span><span class="p">(</span><span class="n">fpath</span><span class="p">)</span></div>



<div class="viewcode-block" id="check_radiation_damping">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.check_radiation_damping.html#wecopttool.check_radiation_damping">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">check_radiation_damping</span><span class="p">(</span>
    <span class="n">hydro_data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
    <span class="n">min_damping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">uniform_shift</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure that the linear hydrodynamics (friction + radiation</span>
<span class="sd">    damping) have positive damping.</span>

<span class="sd">    Shifts the :python:`friction` or :python:`radiation_damping` up</span>
<span class="sd">    if necessary. Returns the (possibly) updated Dataset with</span>
<span class="sd">    :python:`damping` :math:`&gt;=` :python:`min_damping`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hydro_data</span>
<span class="sd">        Linear hydrodynamic data.</span>
<span class="sd">    min_damping</span>
<span class="sd">        Minimum threshold for damping. Default is 1e-6.</span>
<span class="sd">    uniform_shift</span>
<span class="sd">        Boolean that determines whether the damping correction for each</span>
<span class="sd">        degree of freedom is frequency dependent or not. If :python:`True`,</span>
<span class="sd">        the damping correction is applied to :python:`friction` and shifts the</span>
<span class="sd">        damping for all frequencies. If :python:`False`, the damping correction</span>
<span class="sd">        is applied to :python:`radiation_damping` and only shifts the</span>
<span class="sd">        damping for frequencies with negative damping values. Default is</span>
<span class="sd">        :python:`False`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">hydro_data_new</span> <span class="o">=</span> <span class="n">hydro_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">radiation</span> <span class="o">=</span> <span class="n">hydro_data_new</span><span class="p">[</span><span class="s1">&#39;radiation_damping&#39;</span><span class="p">]</span>
    <span class="n">friction</span> <span class="o">=</span> <span class="n">hydro_data_new</span><span class="p">[</span><span class="s1">&#39;friction&#39;</span><span class="p">]</span>
    <span class="n">ndof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hydro_data_new</span><span class="o">.</span><span class="n">influenced_dof</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">ndof</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">hydro_data</span><span class="o">.</span><span class="n">radiating_dof</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">idof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndof</span><span class="p">):</span>
        <span class="n">iradiation</span> <span class="o">=</span> <span class="n">radiation</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">radiating_dof</span><span class="o">=</span><span class="n">idof</span><span class="p">,</span> <span class="n">influenced_dof</span><span class="o">=</span><span class="n">idof</span><span class="p">)</span>
        <span class="n">ifriction</span> <span class="o">=</span> <span class="n">friction</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">radiating_dof</span><span class="o">=</span><span class="n">idof</span><span class="p">,</span> <span class="n">influenced_dof</span><span class="o">=</span><span class="n">idof</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">uniform_shift</span><span class="p">:</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="p">(</span><span class="n">iradiation</span><span class="o">+</span><span class="n">ifriction</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">dmin</span> <span class="o">&lt;=</span> <span class="mf">0.0</span> <span class="o">+</span> <span class="n">min_damping</span><span class="p">:</span>
                <span class="n">dof</span> <span class="o">=</span> <span class="n">hydro_data_new</span><span class="o">.</span><span class="n">influenced_dof</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">idof</span><span class="p">]</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">min_damping</span><span class="o">-</span><span class="n">dmin</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Linear damping for DOF &quot;</span><span class="si">{</span><span class="n">dof</span><span class="si">}</span><span class="s1">&quot; has negative or close &#39;</span> <span class="o">+</span>
                    <span class="s1">&#39;to zero terms. Shifting up radiation damping by &#39;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">delta</span><span class="o">.</span><span class="n">values</span><span class="si">}</span><span class="s1"> N/(m/s).&#39;</span><span class="p">)</span>
                <span class="n">hydro_data_new</span><span class="p">[</span><span class="s1">&#39;radiation_damping&#39;</span><span class="p">][:,</span> <span class="n">idof</span><span class="p">,</span> <span class="n">idof</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">iradiation</span> <span class="o">+</span> <span class="n">delta</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_damping</span> <span class="o">=</span> <span class="n">iradiation</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                <span class="n">iradiation</span><span class="o">+</span><span class="n">ifriction</span><span class="o">&gt;</span><span class="n">min_damping</span><span class="p">,</span> <span class="n">other</span><span class="o">=</span><span class="n">min_damping</span><span class="p">)</span>
            <span class="n">dof</span> <span class="o">=</span> <span class="n">hydro_data_new</span><span class="o">.</span><span class="n">influenced_dof</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">idof</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">new_damping</span><span class="o">==</span><span class="n">min_damping</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Linear damping for DOF &quot;</span><span class="si">{</span><span class="n">dof</span><span class="si">}</span><span class="s1">&quot; has negative or close to &#39;</span> <span class="o">+</span>
                    <span class="s1">&#39;zero terms. Shifting up damping terms &#39;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">new_damping</span><span class="o">==</span><span class="n">min_damping</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> to a minimum of &#39;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">min_damping</span><span class="si">}</span><span class="s1"> N/(m/s)&#39;</span><span class="p">)</span>
            <span class="n">hydro_data_new</span><span class="p">[</span><span class="s1">&#39;radiation_damping&#39;</span><span class="p">][:,</span> <span class="n">idof</span><span class="p">,</span> <span class="n">idof</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_damping</span>
    <span class="k">return</span> <span class="n">hydro_data_new</span></div>



<div class="viewcode-block" id="check_impedance">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.check_impedance.html#wecopttool.check_impedance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">check_impedance</span><span class="p">(</span>
    <span class="n">Zi</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span>
    <span class="n">min_damping</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
    <span class="n">uniform_shift</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DataArray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure that the real part of the impedance (resistive) is positive.</span>

<span class="sd">    Adds to real part of the impedance.</span>
<span class="sd">    Returns the (possibly) updated impedance with</span>
<span class="sd">    :math:`Re(Zi)&gt;=` :python:`min_damping`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Zi</span>
<span class="sd">        Linear hydrodynamic impedance.</span>
<span class="sd">    min_damping</span>
<span class="sd">        Minimum threshold for damping. Default is 1e-6.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Zi_diag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diagonal</span><span class="p">(</span><span class="n">Zi</span><span class="p">,</span><span class="n">axis1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">axis2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">Zi_shifted</span> <span class="o">=</span> <span class="n">Zi</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Zi_diag</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
        <span class="k">if</span> <span class="n">uniform_shift</span><span class="p">:</span>
            <span class="n">dmin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Zi_diag</span><span class="p">[:,</span> <span class="n">dof</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">dmin</span> <span class="o">&lt;</span> <span class="n">min_damping</span><span class="p">:</span>
                <span class="n">delta</span> <span class="o">=</span> <span class="n">min_damping</span> <span class="o">-</span> <span class="n">dmin</span>
                <span class="n">Zi_shifted</span><span class="p">[:,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zi_diag</span><span class="p">[:,</span> <span class="n">dof</span><span class="p">]</span> \
                    <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Real part of impedance for </span><span class="si">{</span><span class="n">dof</span><span class="si">}</span><span class="s1"> has negative or close to &#39;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s1">&#39;zero terms. Shifting up by </span><span class="si">{</span><span class="n">delta</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Zi_diag</span><span class="p">[:,</span> <span class="n">dof</span><span class="p">])</span><span class="o">&lt;</span><span class="n">min_damping</span><span class="p">)</span>
            <span class="n">Zi_dof_real</span> <span class="o">=</span> <span class="n">Zi_diag</span><span class="p">[:,</span><span class="n">dof</span><span class="p">]</span><span class="o">.</span><span class="n">real</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Zi_dof_imag</span> <span class="o">=</span> <span class="n">Zi_diag</span><span class="p">[:,</span><span class="n">dof</span><span class="p">]</span><span class="o">.</span><span class="n">imag</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">Zi_dof_real</span><span class="p">[</span><span class="n">Zi_dof_real</span> <span class="o">&lt;</span> <span class="n">min_damping</span><span class="p">]</span> <span class="o">=</span> <span class="n">min_damping</span>
            <span class="n">Zi_shifted</span><span class="p">[:,</span> <span class="n">dof</span><span class="p">,</span> <span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="n">Zi_dof_real</span> <span class="o">+</span> <span class="n">Zi_dof_imag</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Zi_dof_real</span><span class="o">==</span><span class="n">min_damping</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Real part of impedance for </span><span class="si">{</span><span class="n">dof</span><span class="si">}</span><span class="s1"> has negative or close to &#39;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s1">&#39;zero terms. Shifting up elements &#39;</span>
                    <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Zi_dof_real</span><span class="o">==</span><span class="n">min_damping</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s1"> to a minimum of &#39;</span> <span class="o">+</span>
                    <span class="sa">f</span><span class="s1">&#39; </span><span class="si">{</span><span class="n">min_damping</span><span class="si">}</span><span class="s1"> N/(m/s)&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">Zi_shifted</span></div>



<div class="viewcode-block" id="force_from_rao_transfer_function">
<a class="viewcode-back" href="../../api_docs/wecopttool.force_from_rao_transfer_function.html#wecopttool.force_from_rao_transfer_function">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">force_from_rao_transfer_function</span><span class="p">(</span>
    <span class="n">rao_transfer_mat</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TStateFunction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a force function from its position transfer matrix.</span>

<span class="sd">    This is the position equivalent to the velocity-based</span>
<span class="sd">    :py:func:`wecopttool.force_from_impedance`.</span>

<span class="sd">    If :python:`zero_freq = False` (not default), the mean (DC) component</span>
<span class="sd">    of the transfer matrix (first row) is excluded.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    rao_transfer_mat</span>
<span class="sd">        Complex position transfer matrix.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the first frequency should be zero. Default is</span>
<span class="sd">        :python:`True`.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    force_from_impedance,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">force</span><span class="p">(</span><span class="n">wec</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">,</span> <span class="n">waves</span><span class="p">):</span>
        <span class="n">transfer_mat</span> <span class="o">=</span> <span class="n">mimo_transfer_mat</span><span class="p">(</span><span class="n">rao_transfer_mat</span><span class="p">,</span> <span class="n">zero_freq</span><span class="p">)</span>
        <span class="n">force_fd</span> <span class="o">=</span> <span class="n">wec</span><span class="o">.</span><span class="n">vec_to_dofmat</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transfer_mat</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wec</span><span class="o">.</span><span class="n">time_mat</span><span class="p">,</span> <span class="n">force_fd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">force</span></div>



<div class="viewcode-block" id="force_from_impedance">
<a class="viewcode-back" href="../../api_docs/wecopttool.force_from_impedance.html#wecopttool.force_from_impedance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">force_from_impedance</span><span class="p">(</span>
    <span class="n">omega</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">impedance</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TStateFunction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a force function from its impedance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    omega</span>
<span class="sd">        Radial frequency vector.</span>
<span class="sd">    impedance</span>
<span class="sd">        Complex impedance matrix.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    force_from_rao_transfer_function,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">force_from_rao_transfer_function</span><span class="p">(</span><span class="n">impedance</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span></div>



<div class="viewcode-block" id="force_from_waves">
<a class="viewcode-back" href="../../api_docs/wecopttool.force_from_waves.html#wecopttool.force_from_waves">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">force_from_waves</span><span class="p">(</span><span class="n">force_coeff</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span>
                     <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TStateFunction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a force function from waves excitation coefficients.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    force_coeff</span>
<span class="sd">        Complex excitation coefficients indexed by frequency and</span>
<span class="sd">        direction angle.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">force</span><span class="p">(</span><span class="n">wec</span><span class="p">,</span> <span class="n">x_wec</span><span class="p">,</span> <span class="n">x_opt</span><span class="p">,</span> <span class="n">waves</span><span class="p">):</span>
        <span class="n">force_fd</span> <span class="o">=</span> <span class="n">complex_to_real</span><span class="p">(</span><span class="n">wave_excitation</span><span class="p">(</span><span class="n">force_coeff</span><span class="p">,</span> <span class="n">waves</span><span class="p">),</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">wec</span><span class="o">.</span><span class="n">time_mat</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">:],</span> <span class="n">force_fd</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">force</span></div>



<div class="viewcode-block" id="inertia">
<a class="viewcode-back" href="../../api_docs/wecopttool.inertia.html#wecopttool.inertia">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">inertia</span><span class="p">(</span>
    <span class="n">f1</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">inertia_matrix</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TStateFunction</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create the inertia &quot;force&quot; from the inertia matrix.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    f1</span>
<span class="sd">        Fundamental frequency :python:`f1` [:math:`Hz`].</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies.</span>
<span class="sd">    inertia_matrix</span>
<span class="sd">        Inertia matrix.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">frequency</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">inertia_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">inertia_matrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">rao_transfer_function</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">omega</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">inertia_matrix</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span>
    <span class="n">inertia_fun</span> <span class="o">=</span> <span class="n">force_from_rao_transfer_function</span><span class="p">(</span>
        <span class="n">rao_transfer_function</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">inertia_fun</span></div>



<div class="viewcode-block" id="standard_forces">
<a class="viewcode-back" href="../../api_docs/wecopttool.standard_forces.html#wecopttool.standard_forces">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">standard_forces</span><span class="p">(</span><span class="n">hydro_data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">TForceDict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create functions for linear hydrodynamic forces.</span>

<span class="sd">    Returns a dictionary with the standard linear forces:</span>
<span class="sd">    radiation, hydrostatic, friction, Froude—Krylov, and diffraction.</span>
<span class="sd">    The functions are type :python:`StateFunction` (see Type Aliases in</span>
<span class="sd">    API Documentation).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hydro_data</span>
<span class="sd">        Linear hydrodynamic data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># intrinsic impedance</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>
    <span class="n">A</span> <span class="o">=</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;added_mass&#39;</span><span class="p">]</span>
    <span class="n">B</span> <span class="o">=</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;radiation_damping&#39;</span><span class="p">]</span>
    <span class="n">K</span> <span class="o">=</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;hydrostatic_stiffness&#39;</span><span class="p">]</span>
    <span class="n">Bf</span> <span class="o">=</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;friction&#39;</span><span class="p">]</span>

    <span class="n">rao_transfer_functions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">rao_transfer_functions</span><span class="p">[</span><span class="s1">&#39;radiation&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">B</span> <span class="o">+</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">w</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">A</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="n">rao_transfer_functions</span><span class="p">[</span><span class="s1">&#39;friction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">w</span><span class="o">*</span><span class="n">Bf</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># include zero_freq in hydrostatics</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="p">((</span><span class="n">K</span> <span class="o">+</span> <span class="mi">0</span><span class="n">j</span><span class="p">)</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">({</span><span class="s2">&quot;omega&quot;</span><span class="p">:</span> <span class="n">B</span><span class="o">.</span><span class="n">omega</span><span class="p">},</span> <span class="mi">0</span><span class="p">))</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="n">hs</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">0</span>
    <span class="n">hs</span> <span class="o">=</span> <span class="n">xr</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">tmp</span><span class="p">,</span> <span class="n">hs</span><span class="p">],</span> <span class="n">dim</span><span class="o">=</span><span class="s1">&#39;omega&#39;</span><span class="p">)</span> <span class="c1">#, data_vars=&#39;minimal&#39;)</span>
    <span class="n">rao_transfer_functions</span><span class="p">[</span><span class="s1">&#39;hydrostatics&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">hs</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

    <span class="n">linear_force_functions</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">zero_freq</span><span class="p">)</span> <span class="ow">in</span> <span class="n">rao_transfer_functions</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s2">&quot;omega&quot;</span><span class="p">,</span> <span class="s2">&quot;radiating_dof&quot;</span><span class="p">,</span> <span class="s2">&quot;influenced_dof&quot;</span><span class="p">)</span>
        <span class="n">value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="n">value</span>  <span class="c1"># RHS of equation: ma = Σf</span>
        <span class="n">linear_force_functions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">force_from_rao_transfer_function</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">zero_freq</span><span class="p">))</span>

    <span class="c1"># wave excitation</span>
    <span class="n">excitation_coefficients</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s1">&#39;Froude_Krylov&#39;</span><span class="p">:</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;Froude_Krylov_force&#39;</span><span class="p">],</span>
        <span class="s1">&#39;diffraction&#39;</span><span class="p">:</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;diffraction_force&#39;</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">excitation_coefficients</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">linear_force_functions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">force_from_waves</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">linear_force_functions</span></div>



<div class="viewcode-block" id="run_bem">
<a class="viewcode-back" href="../../api_docs/wecopttool.run_bem.html#wecopttool.run_bem">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">run_bem</span><span class="p">(</span>
    <span class="n">fb</span><span class="p">:</span> <span class="n">cpy</span><span class="o">.</span><span class="n">FloatingBody</span><span class="p">,</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">infty</span><span class="p">],</span>
    <span class="n">wave_dirs</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span>
    <span class="n">rho</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_parameters</span><span class="p">[</span><span class="s1">&#39;rho&#39;</span><span class="p">],</span>
    <span class="n">g</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_parameters</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">],</span>
    <span class="n">depth</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_parameters</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">],</span>
    <span class="n">write_info</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">njobs</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Run Capytaine for a range of frequencies and wave directions.</span>

<span class="sd">    This simplifies running *Capytaine* and ensures the output are in</span>
<span class="sd">    the correct convention (see</span>
<span class="sd">    :py:func:`wecopttool.change_bem_convention`).</span>

<span class="sd">    It creates the *test matrix*, calls</span>
<span class="sd">    :py:meth:`capytaine.bodies.bodies.FloatingBody.keep_immersed_part`,</span>
<span class="sd">    calls :py:meth:`capytaine.bem.solver.BEMSolver.fill_dataset`,</span>
<span class="sd">    and changes the sign convention using</span>
<span class="sd">    :py:func:`wecopttool.change_bem_convention`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fb</span>
<span class="sd">        The WEC as a Capytaine floating body (mesh + DOFs).</span>
<span class="sd">    freq</span>
<span class="sd">        List of frequencies [:math:`Hz`] to evaluate BEM at.</span>
<span class="sd">    wave_dirs</span>
<span class="sd">        List of wave directions [degrees] to evaluate BEM at.</span>
<span class="sd">    rho</span>
<span class="sd">        Water density in :math:`kg/m^3`.</span>
<span class="sd">    g</span>
<span class="sd">        Gravitational acceleration in :math:`m/s^2`.</span>
<span class="sd">    depth</span>
<span class="sd">        Water depth in :math:`m`.</span>
<span class="sd">    write_info</span>
<span class="sd">        Which additional information to write.</span>
<span class="sd">        Options are:</span>
<span class="sd">        :python:`[&#39;hydrostatics&#39;, &#39;mesh&#39;, &#39;wavelength&#39;, &#39;wavenumber&#39;]`.</span>
<span class="sd">        See :py:func:`capytaine.io.xarray.assemble_dataset` for more</span>
<span class="sd">        details.</span>
<span class="sd">    njobs</span>
<span class="sd">        Number of jobs to run in parallel.</span>
<span class="sd">        See :py:meth:`capytaine.bem.solver.BEMSolver.fill_dataset`</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    change_bem_convention,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">wave_dirs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">wave_dirs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">degrees_to_radians</span><span class="p">(</span><span class="n">wave_dirs</span><span class="p">))</span>
    <span class="n">solver</span> <span class="o">=</span> <span class="n">cpy</span><span class="o">.</span><span class="n">BEMSolver</span><span class="p">()</span>
    <span class="n">test_matrix</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">(</span><span class="n">coords</span><span class="o">=</span><span class="p">{</span>
        <span class="s1">&#39;rho&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">rho</span><span class="p">],</span>
        <span class="s1">&#39;water_depth&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">depth</span><span class="p">],</span>
        <span class="s1">&#39;omega&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">ifreq</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="k">for</span> <span class="n">ifreq</span> <span class="ow">in</span> <span class="n">freq</span><span class="p">],</span>
        <span class="s1">&#39;wave_direction&#39;</span><span class="p">:</span> <span class="n">wave_dirs</span><span class="p">,</span>
        <span class="s1">&#39;radiating_dof&#39;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">fb</span><span class="o">.</span><span class="n">dofs</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
        <span class="s1">&#39;g&#39;</span><span class="p">:</span> <span class="p">[</span><span class="n">g</span><span class="p">],</span>
    <span class="p">})</span>
    <span class="k">if</span> <span class="n">wave_dirs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># radiation only problem, no diffraction or excitation</span>
        <span class="n">test_matrix</span> <span class="o">=</span> <span class="n">test_matrix</span><span class="o">.</span><span class="n">drop_vars</span><span class="p">(</span><span class="s1">&#39;wave_direction&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">write_info</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">write_info</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;hydrostatics&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                      <span class="s1">&#39;mesh&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="s1">&#39;wavelength&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="s1">&#39;wavenumber&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                     <span class="p">}</span>
    <span class="n">wec_im</span> <span class="o">=</span> <span class="n">fb</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">fb</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">_immersed&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">keep_immersed_part</span><span class="p">()</span>
    <span class="n">wec_im</span> <span class="o">=</span> <span class="n">set_fb_centers</span><span class="p">(</span><span class="n">wec_im</span><span class="p">,</span> <span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wec_im</span><span class="p">,</span> <span class="s1">&#39;inertia_matrix&#39;</span><span class="p">):</span>
        <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;FloatingBody has no inertia_matrix field. &#39;</span> <span class="o">+</span> 
                     <span class="s1">&#39;If the FloatingBody mass is defined, it will be &#39;</span> <span class="o">+</span> 
                     <span class="s1">&#39;used for calculating the inertia matrix here. &#39;</span> <span class="o">+</span> 
                     <span class="s1">&#39;Otherwise, the neutral buoyancy assumption will &#39;</span> <span class="o">+</span> 
                     <span class="s1">&#39;be used to auto-populate.&#39;</span><span class="p">)</span>
        <span class="n">wec_im</span><span class="o">.</span><span class="n">inertia_matrix</span> <span class="o">=</span> <span class="n">wec_im</span><span class="o">.</span><span class="n">compute_rigid_body_inertia</span><span class="p">(</span><span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">wec_im</span><span class="p">,</span> <span class="s1">&#39;hydrostatic_stiffness&#39;</span><span class="p">):</span>
        <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;FloatingBody has no hydrostatic_stiffness field. &#39;</span> <span class="o">+</span>
                     <span class="s1">&#39;Capytaine will auto-populate the hydrostatic &#39;</span> <span class="o">+</span>
                     <span class="s1">&#39;stiffness based on the provided mesh.&#39;</span><span class="p">)</span>
        <span class="n">wec_im</span><span class="o">.</span><span class="n">hydrostatic_stiffness</span> <span class="o">=</span> <span class="n">wec_im</span><span class="o">.</span><span class="n">compute_hydrostatic_stiffness</span><span class="p">(</span><span class="n">rho</span><span class="o">=</span><span class="n">rho</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>
    <span class="n">bem_data</span> <span class="o">=</span> <span class="n">solver</span><span class="o">.</span><span class="n">fill_dataset</span><span class="p">(</span>
        <span class="n">test_matrix</span><span class="p">,</span> <span class="n">wec_im</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=</span><span class="n">njobs</span><span class="p">,</span> <span class="o">**</span><span class="n">write_info</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">change_bem_convention</span><span class="p">(</span><span class="n">bem_data</span><span class="p">)</span></div>



<div class="viewcode-block" id="change_bem_convention">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.change_bem_convention.html#wecopttool.change_bem_convention">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">change_bem_convention</span><span class="p">(</span><span class="n">bem_data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Change the convention from :math:`-iωt` to :math:`+iωt`.</span>

<span class="sd">    Change the linear hydrodynamic coefficients from the Capytaine</span>
<span class="sd">    convention (:math:`x(t)=Xe^{-iωt}`), where :math:`X` is the</span>
<span class="sd">    frequency-domain response, to the more standard convention</span>
<span class="sd">    used in WecOptTool (:math:`x(t)=Xe^{+iωt}`).</span>

<span class="sd">    NOTE: This might change in Capytaine in the future.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bem_data</span>
<span class="sd">        Linear hydrodynamic coefficients for the WEC.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bem_data</span><span class="p">[</span><span class="s1">&#39;Froude_Krylov_force&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span>
        <span class="n">bem_data</span><span class="p">[</span><span class="s1">&#39;Froude_Krylov_force&#39;</span><span class="p">])</span>
    <span class="n">bem_data</span><span class="p">[</span><span class="s1">&#39;diffraction_force&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conjugate</span><span class="p">(</span><span class="n">bem_data</span><span class="p">[</span><span class="s1">&#39;diffraction_force&#39;</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">bem_data</span></div>



<div class="viewcode-block" id="add_linear_friction">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.add_linear_friction.html#wecopttool.add_linear_friction">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">add_linear_friction</span><span class="p">(</span>
    <span class="n">bem_data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">,</span>
    <span class="n">friction</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add linear friction to BEM data.</span>

<span class="sd">    Returns the Dataset with the additional information added.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bem_data</span>
<span class="sd">        Linear hydrodynamic coefficients obtained using the boundary</span>
<span class="sd">        element method (BEM) code Capytaine, with sign convention</span>
<span class="sd">        corrected. Also includes inertia and hydrostatic stiffness.</span>
<span class="sd">    friction</span>
<span class="sd">        Linear friction, in addition to radiation damping, of size</span>
<span class="sd">        :python:`(ndof, ndof)`.</span>
<span class="sd">        :python:`None` if included in :python:`bem_data` or to set to zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;radiating_dof&#39;</span><span class="p">,</span> <span class="s1">&#39;influenced_dof&#39;</span><span class="p">]</span>
    <span class="n">hydro_data</span> <span class="o">=</span> <span class="n">bem_data</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">deep</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">friction</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="s1">&#39;friction&#39;</span> <span class="ow">in</span> <span class="n">hydro_data</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">hydro_data</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Variable &quot;friction&quot; is already in BEM data &#39;</span> <span class="o">+</span>
                        <span class="sa">f</span><span class="s1">&#39;with different values.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;Variable &quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s1">&quot; is already in BEM data &#39;</span> <span class="o">+</span>
                    <span class="s1">&#39;with same value.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">atleast_2d</span><span class="p">(</span><span class="n">friction</span><span class="p">)</span>
            <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;friction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">friction</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">friction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ndof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">hydro_data</span><span class="p">[</span><span class="s2">&quot;influenced_dof&quot;</span><span class="p">])</span>
        <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;friction&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">dims</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">ndof</span><span class="p">,</span> <span class="n">ndof</span><span class="p">]))</span>

    <span class="k">return</span> <span class="n">hydro_data</span></div>



<div class="viewcode-block" id="wave_excitation">
<a class="viewcode-back" href="../../api_docs/wecopttool.wave_excitation.html#wecopttool.wave_excitation">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">wave_excitation</span><span class="p">(</span><span class="n">exc_coeff</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">waves</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate the complex, frequency-domain, excitation force due to</span>
<span class="sd">    waves.</span>

<span class="sd">    The resulting force is indexed only by frequency and not direction</span>
<span class="sd">    angle.</span>
<span class="sd">    The input :python:`waves` frequencies must be same as</span>
<span class="sd">    :python:`exc_coeff`, but the directions can be a subset.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    exc_coeff</span>
<span class="sd">        Complex excitation coefficients indexed by frequency and</span>
<span class="sd">        direction angle.</span>
<span class="sd">    waves</span>
<span class="sd">        Complex frequency-domain wave elevation.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the frequency vectors of :python:`exc_coeff` and</span>
<span class="sd">        :python:`waves` are different.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If any of the directions in :python:`waves` is not in</span>
<span class="sd">        :python:`exc_coeff`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">omega_w</span> <span class="o">=</span> <span class="n">waves</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">omega_e</span> <span class="o">=</span> <span class="n">exc_coeff</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">dir_w</span> <span class="o">=</span> <span class="n">waves</span><span class="p">[</span><span class="s1">&#39;wave_direction&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">dir_e</span> <span class="o">=</span> <span class="n">exc_coeff</span><span class="p">[</span><span class="s1">&#39;wave_direction&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span>
    <span class="n">exc_coeff</span> <span class="o">=</span> <span class="n">exc_coeff</span><span class="o">.</span><span class="n">values</span>

    <span class="n">wave_elev_fd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">waves</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">omega_w</span><span class="p">,</span> <span class="n">omega_e</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Wave and excitation frequencies do not match. WW: </span><span class="si">{</span><span class="n">omega_w</span><span class="si">}</span><span class="s2">, EE: </span><span class="si">{</span><span class="n">omega_e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="n">subset</span><span class="p">,</span> <span class="n">sub_ind</span> <span class="o">=</span> <span class="n">subset_close</span><span class="p">(</span><span class="n">dir_w</span><span class="p">,</span> <span class="n">dir_e</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">subset</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Some wave directions are not in excitation coefficients &quot;</span> <span class="o">+</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> Wave direction(s): </span><span class="si">{</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dir_w</span><span class="p">))</span><span class="si">}</span><span class="s2"> (deg)&quot;</span> <span class="o">+</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> BEM direction(s): </span><span class="si">{</span><span class="n">np</span><span class="o">.</span><span class="n">rad2deg</span><span class="p">(</span><span class="n">dir_e</span><span class="p">)</span><span class="si">}</span><span class="s2"> (deg).&quot;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">wave_elev_fd</span><span class="o">*</span><span class="n">exc_coeff</span><span class="p">[:,</span> <span class="n">sub_ind</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></div>



<div class="viewcode-block" id="hydrodynamic_impedance">
<a class="viewcode-back" href="../../api_docs/wecopttool.hydrodynamic_impedance.html#wecopttool.hydrodynamic_impedance">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">hydrodynamic_impedance</span><span class="p">(</span><span class="n">hydro_data</span><span class="p">:</span> <span class="n">Dataset</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculate hydrodynamic intrinsic impedance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    hydro_data</span>
<span class="sd">        Dataset with linear hydrodynamic coefficients produced by</span>
<span class="sd">        :py:func:`wecopttool.add_linear_friction`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">hydro_impedance</span> <span class="o">=</span> <span class="p">(</span><span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;inertia_matrix&#39;</span><span class="p">]</span> \
        <span class="o">+</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;added_mass&#39;</span><span class="p">])</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span> \
            <span class="o">+</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;radiation_damping&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;friction&#39;</span><span class="p">]</span> \
                <span class="o">+</span> <span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;hydrostatic_stiffness&#39;</span><span class="p">]</span><span class="o">/</span><span class="mi">1</span><span class="n">j</span><span class="o">/</span><span class="n">hydro_data</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">hydro_impedance</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="s1">&#39;omega&#39;</span><span class="p">,</span> <span class="s1">&#39;radiating_dof&#39;</span><span class="p">,</span> <span class="s1">&#39;influenced_dof&#39;</span><span class="p">)</span></div>



<div class="viewcode-block" id="atleast_2d">
<a class="viewcode-back" href="../../api_docs/wecopttool.core.atleast_2d.html#wecopttool.atleast_2d">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">atleast_2d</span><span class="p">(</span><span class="n">array</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Ensure an array is at least 2D, otherwise add trailing dimensions</span>
<span class="sd">    to make it 2D.</span>

<span class="sd">    This differs from :py:func:`numpy.atleast_2d` in that the additional</span>
<span class="sd">    dimensions are appended at the end rather than at the begining.</span>
<span class="sd">    This might be an option in :py:func:`numpy.atleast_2d` in the</span>
<span class="sd">    future, see</span>
<span class="sd">    `NumPy #12336 &lt;https://github.com/numpy/numpy/issues/12336&gt;`_.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    array</span>
<span class="sd">        Input array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">expand_dims</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="k">else</span> <span class="n">array</span></div>



<div class="viewcode-block" id="degrees_to_radians">
<a class="viewcode-back" href="../../api_docs/wecopttool.degrees_to_radians.html#wecopttool.degrees_to_radians">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">degrees_to_radians</span><span class="p">(</span>
    <span class="n">degrees</span><span class="p">:</span> <span class="n">FloatOrArray</span><span class="p">,</span>
    <span class="n">sort</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Convert a 1D array of angles in degrees to radians in the range</span>
<span class="sd">    :math:`[-π, π)` and optionally sort them.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    degrees</span>
<span class="sd">        1D array of angles in degrees.</span>
<span class="sd">    sort</span>
<span class="sd">        Whether to sort the angles from smallest to largest in</span>
<span class="sd">        :math:`[-π, π)`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">radians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">remainder</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="n">degrees</span><span class="p">),</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">radians</span><span class="p">[</span><span class="n">radians</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="k">if</span> <span class="n">radians</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">sort</span><span class="p">:</span>
        <span class="n">radians</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">radians</span></div>



<div class="viewcode-block" id="subset_close">
<a class="viewcode-back" href="../../api_docs/wecopttool.subset_close.html#wecopttool.subset_close">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">subset_close</span><span class="p">(</span>
    <span class="n">set_a</span><span class="p">:</span> <span class="n">FloatOrArray</span><span class="p">,</span>
    <span class="n">set_b</span><span class="p">:</span> <span class="n">FloatOrArray</span><span class="p">,</span>
    <span class="n">rtol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.e-5</span><span class="p">,</span>
    <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.e-8</span><span class="p">,</span>
    <span class="n">equal_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="nb">list</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the first set :python:`set_a` is contained, to some</span>
<span class="sd">    tolerance, in the second set :python:`set_b`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    set_a</span>
<span class="sd">        First array which is tested for being subset.</span>
<span class="sd">    set_b</span>
<span class="sd">        Second array which is tested for containing :python:`set_a`.</span>
<span class="sd">    rtol</span>
<span class="sd">        The relative tolerance parameter. Passed to</span>
<span class="sd">        :py:func:`numpy.isclose`.</span>
<span class="sd">    atol</span>
<span class="sd">        The absolute tolerance parameter. Passed to</span>
<span class="sd">        :py:func:`numpy.isclose`.</span>
<span class="sd">    equal_nan</span>
<span class="sd">        Whether to compare NaNs as equal. Passed to</span>
<span class="sd">        :py:func:`numpy.isclose`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    subset</span>
<span class="sd">        Whether the first array is a subset of the second array.</span>
<span class="sd">    ind</span>
<span class="sd">        List with integer indices where the first array&#39;s elements are</span>
<span class="sd">        located inside the second array.</span>
<span class="sd">        Only contains values if :python:`subset==True`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If either of the two arrays contains repeated elements.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">set_a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">set_a</span><span class="p">)</span>
    <span class="n">set_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">set_b</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">set_a</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_a</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Elements in set_a not unique&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">set_b</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">decimals</span> <span class="o">=</span> <span class="mi">6</span><span class="p">)))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_b</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Elements in set_b not unique&quot;</span><span class="p">)</span>

    <span class="n">ind</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">set_a</span><span class="p">:</span>
        <span class="n">a_in_b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">set_b</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span>
                            <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span> <span class="n">equal_nan</span><span class="o">=</span><span class="n">equal_nan</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a_in_b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">a_in_b</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">a_in_b</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Multiple matching elements in subset, &#39;</span> <span class="o">+</span>
                         <span class="s1">&#39;selecting closest match.&#39;</span><span class="p">)</span>
            <span class="n">ind</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">a_in_b</span> <span class="o">-</span> <span class="n">el</span><span class="p">)))</span>
    <span class="n">subset</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">set_a</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
    <span class="n">ind</span> <span class="o">=</span> <span class="n">ind</span> <span class="k">if</span> <span class="n">subset</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="k">return</span> <span class="n">subset</span><span class="p">,</span> <span class="n">ind</span></div>



<div class="viewcode-block" id="scale_dofs">
<a class="viewcode-back" href="../../api_docs/wecopttool.scale_dofs.html#wecopttool.scale_dofs">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">scale_dofs</span><span class="p">(</span><span class="n">scale_list</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">ncomponents</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a scaling vector based on a different scale for each DOF.</span>

<span class="sd">    Returns a 1D array of length :python:`NDOF*ncomponents` where the</span>
<span class="sd">    number of DOFs (:python:`NDOF`) is the length of</span>
<span class="sd">    :python:`scale_list`.</span>
<span class="sd">    The first :python:`ncomponents` entries have the value of the first</span>
<span class="sd">    scale :python:`scale_list[0]`, the next :python:`ncomponents`</span>
<span class="sd">    entries have the value of the second scale :python:`scale_list[1]`,</span>
<span class="sd">    and so on.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    scale_list</span>
<span class="sd">        Scale for each DOF.</span>
<span class="sd">    ncomponents</span>
<span class="sd">        Number of elements in the state vector for each DOF.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndof</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">scale_list</span><span class="p">)</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndof</span><span class="p">):</span>
        <span class="n">scale</span> <span class="o">+=</span> <span class="p">[</span><span class="n">scale_list</span><span class="p">[</span><span class="n">dof</span><span class="p">]]</span> <span class="o">*</span> <span class="n">ncomponents</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span></div>



<div class="viewcode-block" id="decompose_state">
<a class="viewcode-back" href="../../api_docs/wecopttool.decompose_state.html#wecopttool.decompose_state">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">decompose_state</span><span class="p">(</span>
    <span class="n">state</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">ndof</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="n">nfreq</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split the state vector into the WEC dynamics state and the</span>
<span class="sd">    optimization (control) state.</span>

<span class="sd">    The WEC dynamics state consists of the Fourier coefficients of</span>
<span class="sd">    the position of each degree of freedom.</span>
<span class="sd">    The optimization state depends on the chosen control states for</span>
<span class="sd">    the problem.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    state</span>
<span class="sd">        Combined WEC and optimization states.</span>
<span class="sd">    ndof</span>
<span class="sd">        Number of degrees of freedom for the WEC dynamics.</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    state_wec</span>
<span class="sd">        WEC state vector.</span>
<span class="sd">    state_opt</span>
<span class="sd">        Optimization (control) state.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nstate_wec</span> <span class="o">=</span> <span class="n">ndof</span> <span class="o">*</span> <span class="n">ncomponents</span><span class="p">(</span><span class="n">nfreq</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">state</span><span class="p">[:</span><span class="n">nstate_wec</span><span class="p">],</span> <span class="n">state</span><span class="p">[</span><span class="n">nstate_wec</span><span class="p">:]</span></div>



<div class="viewcode-block" id="frequency_parameters">
<a class="viewcode-back" href="../../api_docs/wecopttool.frequency_parameters.html#wecopttool.frequency_parameters">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">frequency_parameters</span><span class="p">(</span>
    <span class="n">freqs</span><span class="p">:</span> <span class="n">ArrayLike</span><span class="p">,</span>
    <span class="n">zero_freq</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the fundamental frequency and the number of frequencies</span>
<span class="sd">    in a frequency array.</span>

<span class="sd">    This function can be used as a check for inputs to other functions</span>
<span class="sd">    since it raises an error if the frequency vector does not have</span>
<span class="sd">    the correct format :python:`freqs = [0, f1, 2*f1, ..., nfreq*f1]`</span>
<span class="sd">    (or :python:`freqs = [f1, 2*f1, ..., nfreq*f1]` if</span>
<span class="sd">    :python:`zero_freq = False`).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    freqs</span>
<span class="sd">        The frequency array, starting at zero and having equal spacing.</span>
<span class="sd">    zero_freq</span>
<span class="sd">        Whether the first frequency should be zero.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    f1</span>
<span class="sd">        Fundamental frequency :python:`f1` [:math:`Hz`]</span>
<span class="sd">    nfreq</span>
<span class="sd">        Number of frequencies (not including zero frequency),</span>
<span class="sd">        i.e., :python:`freqs = [0, f1, 2*f1, ..., nfreq*f1]`.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the frequency vector is not evenly spaced.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the zero-frequency was expected but not included or not</span>
<span class="sd">        expected but included.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
            <span class="n">freqs0</span> <span class="o">=</span> <span class="n">freqs</span><span class="p">[:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Zero frequency was included.&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">zero_freq</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Frequency array must start with the zero frequency.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freqs0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([[</span><span class="mf">0.0</span><span class="p">,],</span> <span class="n">freqs</span><span class="p">])</span>

    <span class="n">f1</span> <span class="o">=</span> <span class="n">freqs0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">nfreq</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">freqs0</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">f_check</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">f1</span><span class="o">*</span><span class="p">(</span><span class="n">nfreq</span><span class="o">+</span><span class="mf">0.5</span><span class="p">),</span> <span class="n">f1</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">f_check</span><span class="p">,</span> <span class="n">freqs0</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Frequency array &#39;omega&#39; must be evenly spaced by&quot;</span> <span class="o">+</span>
                         <span class="s2">&quot;the fundamental frequency &quot;</span> <span class="o">+</span>
                         <span class="s2">&quot;(i.e., &#39;omega = [0, f1, 2*f1, ..., nfreq*f1]&#39;)&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">f1</span><span class="p">,</span> <span class="n">nfreq</span></div>



<div class="viewcode-block" id="time_results">
<a class="viewcode-back" href="../../api_docs/wecopttool.time_results.html#wecopttool.time_results">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">time_results</span><span class="p">(</span><span class="n">fd</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">,</span> <span class="n">time</span><span class="p">:</span> <span class="n">DataArray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a :py:class:`xarray.DataArray` of time-domain results from</span>
<span class="sd">    :py:class:`xarray.DataArray` of frequency-domain results.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fd</span>
<span class="sd">        Frequency domain response.</span>
<span class="sd">    time</span>
<span class="sd">        Time array.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="o">*</span><span class="n">fd</span><span class="o">.</span><span class="n">isel</span><span class="p">(</span><span class="n">omega</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">time</span><span class="p">)))</span>
    <span class="k">for</span> <span class="n">w</span><span class="p">,</span> <span class="n">mag</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fd</span><span class="o">.</span><span class="n">omega</span><span class="p">,</span> <span class="n">fd</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">out</span> <span class="o">+</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">time</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">mag</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">w</span><span class="o">*</span><span class="n">time</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span></div>



<div class="viewcode-block" id="set_fb_centers">
<a class="viewcode-back" href="../../api_docs/wecopttool.set_fb_centers.html#wecopttool.set_fb_centers">[docs]</a>
<span class="k">def</span><span class="w"> </span><span class="nf">set_fb_centers</span><span class="p">(</span>
    <span class="n">fb</span><span class="p">:</span> <span class="n">FloatingBody</span><span class="p">,</span>
    <span class="n">rho</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">_default_parameters</span><span class="p">[</span><span class="s2">&quot;rho&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">FloatingBody</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sets default properties if not provided by the user:</span>
<span class="sd">        - `center_of_mass` is set to the geometric centroid</span>
<span class="sd">        - `rotation_center` is set to the center of mass</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">valid_properties</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;center_of_mass&#39;</span><span class="p">,</span> <span class="s1">&#39;rotation_center&#39;</span><span class="p">]</span>

    <span class="k">for</span> <span class="nb">property</span> <span class="ow">in</span> <span class="n">valid_properties</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="nb">property</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="nb">property</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="nb">property</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">property</span> <span class="o">==</span> <span class="s1">&#39;center_of_mass&#39;</span><span class="p">:</span>
                <span class="n">def_val</span> <span class="o">=</span> <span class="n">fb</span><span class="o">.</span><span class="n">center_of_buoyancy</span>
                <span class="n">log_str</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Using the geometric centroid as the center of gravity (COG).&quot;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">property</span> <span class="o">==</span> <span class="s1">&#39;rotation_center&#39;</span><span class="p">:</span>
                <span class="n">def_val</span> <span class="o">=</span> <span class="n">fb</span><span class="o">.</span><span class="n">center_of_mass</span>
                <span class="n">log_str</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="s2">&quot;Using the center of gravity (COG) as the rotation center &quot;</span> <span class="o">+</span>
                    <span class="s2">&quot;for hydrostatics.&quot;</span><span class="p">)</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="nb">property</span><span class="p">,</span> <span class="n">def_val</span><span class="p">)</span>
            <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">log_str</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span> <span class="nb">property</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="nb">property</span><span class="si">}</span><span class="s1"> already defined as </span><span class="si">{</span><span class="nb">getattr</span><span class="p">(</span><span class="n">fb</span><span class="p">,</span><span class="w"> </span><span class="nb">property</span><span class="p">)</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">fb</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020 National Technology &amp; Engineering Solutions of Sandia, LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S. Government retains certain rights in this software.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <div class="rst-versions" data-toggle="rst-versions" role="note" aria-label="versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    <span class="fa fa-book"> Other Versions</span>
    Version: latest
    <span class="fa fa-caret-down"></span>
  </span>
  <div class="rst-other-versions"><dl>
      <dt>Branches</dt><dd><a href="./_modules/wecopttool/core.html">latest</a></dd><dd><a href="./dev/_modules/wecopttool/core.html">dev</a></dd></dl></div>
</div><script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>